删除与模型相关的表：

```js
await User.drop();
console.log("用户表已删除!");
```

删除所有表：

```js
await sequelize.drop();
console.log("所有表已删除!");
```

### 日期

```js
DataTypes.DATE       // DATETIME 适用于 mysql / sqlite, 带时区的TIMESTAMP 适用于 postgres
DataTypes.DATE(6)    // DATETIME(6) 适用于 mysql 5.6.4+. 支持6位精度的小数秒
DataTypes.DATEONLY   // 不带时间的 DATE
```

### UUID

对于 UUID,使用 `DataTypes.UUID`. 对于 PostgreSQL 和 SQLite,它会是 `UUID` 数据类型;对于 MySQL,它则变成`CHAR(36)`, `Sequelize 可以自动为这些字段生成 UUID`,只需使用 `DataTypes.UUIDV1` 或 `DataTypes.UUIDV4` 作为默认值即可：

```js
{
  type: DataTypes.UUID,
  defaultValue: DataTypes.UUIDV4 // 或 DataTypes.UUIDV1
}
```



`unique: 'compositeIndex'` 的设置,意味着 `uniqueOne` 和 `uniqueTwo` 这两个字段创建一个复合唯一索引。字段的组合必须是`唯一`的，换句话说，每一对 (`uniqueOne`, `uniqueTwo`) 的值都必须在表中是唯一的。

```javascript
 uniqueOne: { type: DataTypes.STRING,  unique: 'compositeIndex' },
 uniqueTwo: { type: DataTypes.INTEGER, unique: 'compositeIndex' },
```



以下的两种方法都是等效的，都是确保`someUnique`字段的唯一性


```javascript
第一种:
Foo.init({someUnique: { type: DataTypes.STRING, unique: true},{sequelize});
第二种:
Foo.init({someUnique: { type: DataTypes.STRING},{sequelize,indexes: [{ unique: true, fields: ['someUnique'] }]});
```

查询指定字段,直接在attributes(属性)中添加

```javascript
 const aa=await Foo.findAll({
        attributes:['barId']
    });
```

