删除与模型相关的表：

```js
await User.drop();
console.log("用户表已删除!");
```

删除所有表：

```js
await sequelize.drop();
console.log("所有表已删除!");
```

### 日期

```js
DataTypes.DATE       // DATETIME 适用于 mysql / sqlite, 带时区的TIMESTAMP 适用于 postgres
DataTypes.DATE(6)    // DATETIME(6) 适用于 mysql 5.6.4+. 支持6位精度的小数秒
DataTypes.DATEONLY   // 不带时间的 DATE
```

### UUID

对于 UUID,使用 `DataTypes.UUID`. 对于 PostgreSQL 和 SQLite,它会是 `UUID` 数据类型;对于 MySQL,它则变成`CHAR(36)`, `Sequelize 可以自动为这些字段生成 UUID`,只需使用 `DataTypes.UUIDV1` 或 `DataTypes.UUIDV4` 作为默认值即可：

```js
{
  type: DataTypes.UUID,
  defaultValue: DataTypes.UUIDV4 // 或 DataTypes.UUIDV1
}
```



`unique: 'compositeIndex'` 的设置,意味着 `uniqueOne` 和 `uniqueTwo` 这两个字段创建一个复合唯一索引。字段的组合必须是`唯一`的，换句话说，每一对 (`uniqueOne`, `uniqueTwo`) 的值都必须在表中是唯一的。

```javascript
 uniqueOne: { type: DataTypes.STRING,  unique: 'compositeIndex' },
 uniqueTwo: { type: DataTypes.INTEGER, unique: 'compositeIndex' },
```



以下的两种方法都是等效的，都是确保`someUnique`字段的唯一性


```javascript
第一种:
Foo.init({someUnique: { type: DataTypes.STRING, unique: true},{sequelize});
第二种:
Foo.init({someUnique: { type: DataTypes.STRING},{sequelize,indexes: [{ unique: true, fields: ['someUnique'] }]});
```

查询指定字段,直接在attributes(属性)中添加

```javascript
 const aa=await Foo.findAll({
        attributes:['barId']
    });
```



由此可见 , 每一条记录都是模型user的实例

```javascript
// 查询所有用户
const users = await User.findAll();
console.log(users.every(user => user instanceof User)); // true
console.log("All users:", JSON.stringify(users, null, 2));
```

[every的作用](C:\Users\86166\Desktop\koa-1\sequelize学习笔记\js知识\every的作用.md)





批量创建和验证

```javascript
const Foo = sequelize.define('foo', {
  name: {
    type: DataTypes.TEXT,
    validate: {
      len: [4, 6]
    }
  }
});

// 这不会引发错误,两个实例都将被创建
await Foo.bulkCreate([
  { name: 'abc123' },
  { name: 'name too long' }
]);

// 这将引发错误,不会创建任何内容
await Foo.bulkCreate([
  { name: 'abc123' },
  { name: 'name too long' }
], { validate: true });

//只保留部分字段:
await User.bulkCreate([
  { username: 'foo' },
  { username: 'bar', admin: true }
], { fields: ['username'] });
// foo 和 bar 都不会是管理员.
```

