删除与模型相关的表：

```js
await User.drop();
console.log("用户表已删除!");
```

删除所有表：

```js
await sequelize.drop();
console.log("所有表已删除!");
```

### 日期

```js
DataTypes.DATE       // DATETIME 适用于 mysql / sqlite, 带时区的TIMESTAMP 适用于 postgres
DataTypes.DATE(6)    // DATETIME(6) 适用于 mysql 5.6.4+. 支持6位精度的小数秒
DataTypes.DATEONLY   // 不带时间的 DATE
```

### UUID

对于 UUID,使用 `DataTypes.UUID`. 对于 PostgreSQL 和 SQLite,它会是 `UUID` 数据类型;对于 MySQL,它则变成`CHAR(36)`, `Sequelize 可以自动为这些字段生成 UUID`,只需使用 `DataTypes.UUIDV1` 或 `DataTypes.UUIDV4` 作为默认值即可：

```js
{
  type: DataTypes.UUID,
  defaultValue: DataTypes.UUIDV4 // 或 DataTypes.UUIDV1
}
```



`unique: 'compositeIndex'` 的设置,意味着 `uniqueOne` 和 `uniqueTwo` 这两个字段创建一个复合唯一索引。字段的组合必须是`唯一`的，换句话说，每一对 (`uniqueOne`, `uniqueTwo`) 的值都必须在表中是唯一的。

```javascript
 uniqueOne: { type: DataTypes.STRING,  unique: 'compositeIndex' },
 uniqueTwo: { type: DataTypes.INTEGER, unique: 'compositeIndex' },
```



以下的两种方法都是等效的，都是确保`someUnique`字段的唯一性


```javascript
第一种:
Foo.init({someUnique: { type: DataTypes.STRING, unique: true},{sequelize});
第二种:
Foo.init({someUnique: { type: DataTypes.STRING},{sequelize,indexes: [{ unique: true, fields: ['someUnique'] }]});
```



你可能已经注意到 `User_Profiles` 表中没有 `id` 字段. 如上所述,它具有复合唯一键. 该复合唯一密钥的名称由 Sequelize 自动选择,但可以使用 `uniqueKey` 参数进行自定义：

```json
{
  "id": 1,
  "username": "p4dm3",
  "points": 1000,
  "profiles": [
    {
      "id": 1,
      "name": "Queen",
      "User_Profile": {
        "selfGranted": true,
        "userId": 1,
        "profileId": 1
      }
    }
  ]
}
```

你可能已经注意到 `User_Profiles` 表中没有 `id` 字段. 如上所述,它具有复合唯一键，该复合唯一密钥的名称由 Sequelize 自动选择,但可以使用 `uniqueKey` 参数进行自定义：

```js
User.belongsToMany(Profile, { through: User_Profiles, uniqueKey: 'my_custom_unique' });
```

```javascript
通义灵码:
const User_Profile = sequelize.define('User_Profile', {
  selfGranted: DataTypes.BOOLEAN,
  // 在模型定义中直接指定复合唯一键
  uniqueKeys: {
    user_profile_unique: {
      fields: ['UserId', 'ProfileId']
    }
  }
});

User.belongsToMany(Profile, { 
  through: User_Profile, 
  // 外键名可以在这里指定，但复合唯一键应在模型定义中设置
  foreignKey: 'UserId', 
  otherKey: 'ProfileId'
});

chatGPT-4o
要正确设置唯一复合键，通常需要在模型定义中使用 indexes 选项来指定多个字段的唯一约束。下面是修改后的代码：
const User_Profile = sequelize.define('User_Profile', {
  selfGranted: DataTypes.BOOLEAN,
  // 在模型定义中直接指定复合唯一键
  uniqueKeys: {
    user_profile_unique: {
      fields: ['UserId', 'ProfileId']
    }
  }
});

User.belongsToMany(Profile, { 
  through: User_Profile, 
  // 外键名可以在这里指定，但复合唯一键应在模型定义中设置
  foreignKey: 'UserId', 
  otherKey: 'ProfileId'
});
```





查询指定字段,直接在attributes(属性)中添加

```javascript
 const aa=await Foo.findAll({
        attributes:['barId']
    });
```



由此可见 , 每一条记录都是模型user的实例

```javascript
// 查询所有用户
const users = await User.findAll();
console.log(users.every(user => user instanceof User)); // true
console.log("All users:", JSON.stringify(users, null, 2));
```

[every的作用](C:\Users\86166\Desktop\koa-1\sequelize学习笔记\js知识\every的作用.md)







批量创建和验证

```javascript
const Foo = sequelize.define('foo', {
  name: {
    type: DataTypes.TEXT,
    validate: {
      len: [4, 6]
    }
  }
});

// 这不会引发错误,两个实例都将被创建
await Foo.bulkCreate([
  { name: 'abc123' },
  { name: 'name too long' }
]);

// 这将引发错误,不会创建任何内容
await Foo.bulkCreate([
  { name: 'abc123' },
  { name: 'name too long' }
], { validate: true });

//只保留部分字段:
await User.bulkCreate([
  { username: 'foo' },
  { username: 'bar', admin: true }
], { fields: ['username'] });
// foo 和 bar 都不会是管理员.
```

按照关联对象中的元素进行排序:

```javascript
await Subtask.findAll({
        include: [{
            model: Product,
            attributes: ["num"],
        }],
        order: [
        [Product, 'num', 'DESC']
    ]
    })

js方法排序:

// 示例数组
const array = [
    { id: 3, name: 'Alice' },
    { id: 1, name: 'Bob' },
    { id: 2, name: 'Charlie' }
];

// 根据 id 进行降序排序
array.sort((a, b) => b.id - a.id);

[
    { id: 3, name: 'Alice' },
    { id: 2, name: 'Charlie' },
    { id: 1, name: 'Bob' }
]


这样，你就可以根据 id 属性的大小对数组中的对象进行降序排序了。
```





### 由于关联表无法在主表的查询中进行分组

`以下均为不成功的案例,包括GPT提供的修改方案`

wu qy, [2024/6/16 14:31]

```javascript
await Subtask.findAll({
        attributes: [],
        include: [{
            model: Product,
            attributes: [
                'num',
                [sequelize.fn('COUNT', sequelize.col('Product.num')), 'count']
            ]
        }],
        group: ['Product.num']
    });
```

存在什么逻辑上的错误吗,为什么无法通过Subtask表,查询关联表Product的字段并进行分组?

mybot899, [2024/6/16 14:31]
你提到的问题确实存在一些逻辑上的错误。主要原因是你试图在 include 中使用 group，而实际上 group 应该在主查询中。此外，COUNT 函数应该在主查询中进行，而不是在 include 的 attributes 中进行。

### 主要问题

1. COUNT 函数的位置: COUNT 函数应该在主查询的 attributes 中，而不是在 include 的 attributes 中。
2. group 的位置: group 应该在主查询中，而不是在 include 中。

### 修改后的代码

以下是修改后的代码：`其实修改后还是无法查询,所以主表中的查询在进行分组的时候不要加上关联表,更不要在主表中为关联表进行统计个数然后依据关联表进行分组等等操作`

```javascript
await Subtask.findAll({
    attributes: [
        [sequelize.col('Product.num'), 'num'],
        [sequelize.fn('COUNT', sequelize.col('Product.num')), 'count']
    ],
    include: [{
        model: Product,
        attributes: []
    }],
    group: ['Product.num']
});
```




### 解释

1. attributes:
   - 主查询的 attributes 中包含了 Product.num 和 COUNT 函数。这里我们使用 sequelize.col 来引用关联模型的字段。

2. include:
   - include 中包含了 Product 模型，但不需要在 attributes 中指定任何字段，因为我们在主查询的 attributes 中已经指定了需要的字段。

3. group:
   - group 在主查询中，按照 Product.num 属性进行分组。

### 完整代码 `无法实现的无效代码,仅作为一个示范`

```javascript
await Subtask.findAll({
    attributes: [
        [sequelize.col('Product.num'), 'num'],
        [sequelize.fn('COUNT', sequelize.col('Product.num')), 'count']
    ],
    include: [{
        model: Product,
        attributes: []
    }],
    group: ['Product.num']
});
```


这样修改后，查询将会根据 Product.num 属性进行分组，并计算每个 num 的计数。希望这对你有所帮助！

### 错误原因分析

`主表Subtasks`和`关联表Product`

```mysql
SELECT `Product`.`num` AS `num`, COUNT(`Product`.`num`) AS `count` FROM `Subtasks` AS `Subtask` LEFT OUTER JOIN `products` AS `product` ON `Subtask`.`id` = `product`.`productId` GROUP BY `Product`.`num`;
```



findAll查询最大值

`千万不能少中括号`

```javascript
await Subtask.findAll({
        attributes: [//千万不能少中括号
            [sequelize.fn('MAX', sequelize.col('age')), 'maxAge']
        ]
    });
```



将使用关联名称`Product` 排序

```javascript
 const aa1 = await Subtask.findAll({//Product
        include: [{
            model: Product,
            attributes: ["num"],
        }],
         order: [
            [Product, 'num', 'DESC'],
         ]
    });
```



内联查询` required: true`

```javascript
User.findAll({
  include: {
    model: Task,
    required: true
  }
});
```



关联表的预先加载过滤,在include中加入`where`子句

```javascript
User.findAll({
  include: {
    model: Tool,
    as: 'Instruments'
    where: {
      size: {
        [Op.ne]: 'small'
      }
    }
  }
});
```



通过`Sequelize.col('project.state')`直接访问到了主表中的字段 ， 这样就能用关联表的字段和主表中的字段进行比较等等操作。

```javascript
// 查找所有具有至少一项任务的项目,其中 task.state === project.state
Project.findAll({
  include: {
    model: Task,
    where: {
      state: Sequelize.col('project.state')
    }
  }
})
```



### 顶层的复杂 where 子句

为了获得涉及嵌套列的顶级 `WHERE` 子句,Sequelize 提供了一种引用嵌套列的方法：`'$nested.column$'` 语法.

例如,它可以用于将 `where` 条件从包含的模型从 `ON` 条件移动到顶层的 `WHERE` 子句.

```js
User.findAll({
  where: {
    '$Instruments.size$': { [Op.ne]: 'small' }
  },
  include: [{
    model: Tool,
    as: 'Instruments'
  }]
});
```



以下两者是等效的

第一种方法:

```javascript
 // 顶级 where, 默认使用 `required: false`,即非内联查询,可能是左表或右表
await Subtask.findAll({
        attributes: [],
        where: {
            '$product.num$': { [Op.eq]: 56 }
        },
        include: [{
            // attributes: ['num'],
            model: Product
            // required: true //如果需要内联查询
        }],
    })
```

第二种方法:

```javascript
// Inner where, 默认使用 `required: true`
 await Subtask.findAll({
        attributes: [],
        include: [{
            // attributes: ['num'],
            model: Product,
            where: {
                num: { [Op.eq]: 56 }
            },
             // required: false //左表查询 
        }],
    })
```

左表和右表查询

```javascript
User.findAll({
  include: [{
    model: Task // 将创建一个 left join
  }]
});
User.findAll({
  include: [{
    model: Task,
    right: true // 将创建一个 right join
  }]
});
User.findAll({
  include: [{
    model: Task,
    required: true,
    right: true // 没有效果, 将创建一个 inner join
  }]
});
User.findAll({
  include: [{
    model: Task,
    where: { name: { [Op.ne]: 'empty trash' } },
    right: true // 没有效果, 将创建一个 inner join
  }]
});
User.findAll({
  include: [{
    model: Tool,
    where: { name: { [Op.ne]: 'empty trash' } },
    required: false // 将创建一个 left join
  }]
});
User.findAll({
  include: [{
    model: Tool,
    where: { name: { [Op.ne]: 'empty trash' } },
    required: false
    right: true // 将创建一个 right join
  }]
});
```





如果你不需要联结表中的任何内容,则可以在 `include` 选项的 `through` 内显式地为 `attributes` 参数提供一个空数组,在这种情况下,将不会获取任何内容,甚至不会创建额外的属性：

```js
Foo.findOne({
  include: {
    model: Bar,
    through: {
      attributes: []
    }
  }
});
```





每当包含 "多对多" 关系中的模型时,也可以在联结表上应用过滤器. 这是通过在 `include` 的 `through` 参数中应用 `where` 参数来完成的. 例如：

```js
User.findAll({
  include: [{
    model: Project,
    through: {
      where: {
        // 这里,`completed` 是联结表上的一列
        completed: true
      }
    }
  }]
});
```





## `nested` 参数包括一切

要包括所有关联的模型,可以使用 `all` 和 `nested` 参数：

```js
// 提取与用户关联的所有模型,是一个点发散到多个点的结构
User.findAll({ include: { all: true }});

// 递归获取与用户及其嵌套关联的关联的所有模型,只要关联的表中还有关联,那么都会展现出来,是一个树型结构
User.findAll({ include: { all: true, nested: true }});
```





include 中添加一个 `where` 子句会自动使它成为 required：true

```js
User.findAndCountAll({
  include: [
    { model: Profile, where: { active: true } }
  ],
  limit: 3
});
```



以下两种数据创建并关联的方式是等效的:

第一种: 创建带有嵌套关联的实例，如果有嵌套的话，通过`association`属性添加关联，否则直接在`include`添加

```javascript
Product.User = Product.belongsTo(User);
User.Addresses = User.hasMany(Address);
```



```javascript
await  Product.create({
    title: 'Chair',
    user: {
        firstName: 'Mick',
        lastName: 'Broadstone',
        addresses: [{
            type: 'home',
            line1: '100 Main St.',
            city: 'Austin',
            state: 'TX',
            zip: '78704'
        }]
    }
}, {
    include: [{
 //  association: 'user', include: 'addresses',直接填关联表在主表中的属性名称也是可以的
        association: Product.User,
        include: [User.Addresses]
    }]
});
```

第二种:`通过外键关联，如下面的 userId`

```javascript
const user = await User.create({
        firstName: 'Mick',
        lastName: 'Broadstone',
    })
    const product = await Product.create({
        title: 'Chair', userId: user.id
    })
    const addresses = await Address.create({
        type: 'home',
        line1: '100 Main St.',
        city: 'Austin',
        state: 'TX',
        zip: '78704',
        userId: user.id
    })
```



#### 没有使用超级多对多，向联结表中插入数据

```javascript
const User = sequelize.define('user', {
  username: DataTypes.STRING,
  points: DataTypes.INTEGER
}, { timestamps: false });
const Profile = sequelize.define('profile', {
  name: DataTypes.STRING
}, { timestamps: false });
const User_Profile = sequelize.define('User_Profile', {
  selfGranted: DataTypes.BOOLEAN
}, { timestamps: false });
```

```javascript
User.belongsToMany(Profile, { through: User_Profile });
Profile.belongsToMany(User, { through: User_Profile });
```

```javascript
const amidala = await User.create({ username: 'p4dm3', points: 1000 });
const queen = await Profile.create({ name: 'Queen' });
```

就是通过`add`的方法中的`through`添加，`add`仅使用与多对多，一对一和一对多是不支持的 ; 像set,get,remove等等,都是在sequelize层面操作数据库的 , 并不能对数据库中的数据带来改变。[数据库关联和实例关联.](C:\Users\86166\Desktop\koa-1\sequelize学习笔记\数据库关联和实例关联.md)

```javascript
await amidala.addProfile(queen, { through: { selfGranted: false } });
```

