## 隔离级别[#](https://www.sequelize.cn/other-topics/transactions#隔离级别)

启动事务时可能使用的隔离级别：

```js
const { Transaction } = require('sequelize');

// 以下是有效的隔离级别:
Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED // "READ UNCOMMITTED"
Transaction.ISOLATION_LEVELS.READ_COMMITTED // "READ COMMITTED"
Transaction.ISOLATION_LEVELS.REPEATABLE_READ  // "REPEATABLE READ"
Transaction.ISOLATION_LEVELS.SERIALIZABLE // "SERIALIZABLE"
```



在 Sequelize，一个 ORM（对象关系映射）库中，`Transaction` 类用于处理数据库事务，确保一系列数据库操作的原子性和一致性。事务中的隔离级别定义了在并发事务中数据的可见性和事务之间的影响程度。 Sequelize 提供了四种标准的 SQL 隔离级别，它们分别是：

1. **Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED**
   - **描述**: "READ UNCOMMITTED" 级别允许事务读取未提交的更改（脏读）。这意味着一个事务可以看到其他事务尚未完成的修改，这可能导致数据不一致或不可重复读的问题。这是最低的隔离级别，提供了最少的并发控制。
2. **Transaction.ISOLATION_LEVELS.READ_COMMITTED**
   - **描述**: "READ COMMITTED" 级别确保事务只能读取已经提交的更改。在这个级别下，脏读不会发生，但是不可重复读可能发生，即在同一事务中多次执行相同的查询可能会得到不同的结果，因为其他事务在这两次查询之间可能已经提交了新的数据。
3. **Transaction.ISOLATION_LEVELS.REPEATABLE_READ**
   - **描述**: "REPEATABLE READ" 级别保证在同一个事务中，多次执行相同的查询会看到相同的数据，即使其他事务已经对这些数据进行了修改并提交。这防止了不可重复读，但可能会导致幻读（同一事务内插入新记录后，查询结果不一致），某些数据库通过额外的机制解决了幻读问题。
4. **Transaction.ISOLATION_LEVELS.SERIALIZABLE**
   - **描述**: "SERIALIZABLE" 是最高的隔离级别，它通过锁定读取的数据来模拟串行执行事务，从而避免了脏读、不可重复读和幻读。在这个级别下，事务之间的影响最小，但可能导致更多的锁竞争和性能下降。

在创建事务时，你可以指定所需的隔离级别，例如：

```js
const t = await sequelize.transaction({ isolationLevel: Transaction.ISOLATION_LEVELS.REPEATABLE_READ });
```

选择正确的隔离级别取决于你的应用程序对一致性和性能的需求。更高的隔离级别通常意味着更强的数据一致性，但可能牺牲一部分并发性能。



默认情况下,sequelize 使用数据库的隔离级别. 如果要使用其他隔离级别,请传入所需的级别作为第一个参数：

```js
const { Transaction } = require('sequelize');

await sequelize.transaction({
  isolationLevel: Transaction.ISOLATION_LEVELS.SERIALIZABLE
}, async (t) => {
  // 你的代码
});
```



你还可以使用 Sequelize 构造函数中的一个参数来全局覆盖 `isolationLevel` 设置：

```js
const { Sequelize, Transaction } = require('sequelize');

const sequelize = new Sequelize('sqlite::memory:', {
  isolationLevel: Transaction.ISOLATION_LEVELS.SERIALIZABLE
});
```



#### 示例

```javascript
User.afterSave((instance, options) => {
  if (options.transaction) {
    // 在事务中保存完成,
    // 等待事务提交以通知侦听器实例已保存
    options.transaction.afterCommit(() => /* 通知 */)
    return;
  }
  // 在事务外保存完成,使调用者可以安全地获取更新的模型
  // 通知
});
```

`afterSave`监听保存后的生命周期函数,当保存完成了,触发`afterSave`函数，如果此生命周期函数的实例上使用的事务,options.transaction==true，然后执行`afterCommit`生命周期函数，即事务提交后触发。



#### 示例

```javascript
User.addHook('afterCreate', async (user, options) => {
  // 我们可以使用 `options.transaction` 来执行
  // 与触发此 hook 的调用相同的事务来执行其他一些调用
  await User.update({ mood: 'sad' }, {
    where: {
      id: user.id
    },
    transaction: options.transaction
  });
});

await sequelize.transaction(async t => {
  await User.create({
    username: 'someguy',
    mood: 'happy'
  }, {
    transaction: t
  });
});
```

`afterCreate`创建后触发，`await sequelize.transaction(async t => {})`自动提交事务，`User.addHook('afterCreate',(user, options)=>{})`创建后触发，里面使用了更新数据库的方法`User.update`，即一创建成功了就通过生命周期函数来改变`mood: 'happy'`为`mood: 'sad' `，由于此实例上使用了事务，所以也必须使用，否则会更新失败，通过生命周期函数的`options`来获取实例上的事务，以此来保持事务的一致性，即都在一个事务中，即创建和更新操作都成功了就会提交事务。我理解得正确吗?

```javascript
GPT-4:
你的理解基本是正确的，但我可以帮你进一步澄清和确认一下。
生命周期钩子 `afterCreate`:
你定义了一个 `afterCreate` 钩子，这个钩子会在 `User` 实例创建之后触发。
在这个钩子中，你使用 `User.update` 方法来更新刚刚创建的用户的 `mood` 属性为 `'sad'`。
你传递了 `options.transaction` 给 `User.update`，这是为了确保更新操作在同一个事务中进行。
事务管理:
你使用 `sequelize.transaction` 方法来创建一个事务，并在这个事务中执行 `User.create` 操作。
事务 `t` 被传递给 `User.create` 的选项中，这样创建操作就会在这个事务中进行。
由于 `afterCreate` 钩子中的 `User.update` 也使用了同一个事务 `options.transaction`，所以创建和更新操作都在同一个事务中进行。
事务的一致性:
通过在 `afterCreate` 钩子中使用传递的事务选项，你确保了创建和更新操作的一致性。
如果任何一个操作失败，整个事务都会回滚，确保数据库状态的一致性。
总结起来，你的理解是正确的：
`afterCreate` 钩子在创建后触发，并通过 `User.update` 更新 `mood` 属性。
事务 `t` 确保了创建和更新操作在同一个事务中进行。
如果创建和更新操作都成功，事务会提交，否则会回滚。
这样做的目的是确保数据的一致性和完整性。
```







在高并发环境下，如果多个客户端同时对同一个数据进行修改（例如库存的更改），确实可能会出现竞态条件（race conditions），导致数据不一致，甚至出现超卖的情况。这是因为多个事务可能同时读取相同的数据，然后进行不一致的更新。

为了避免这种情况，可以使用以下几种方法：

### 1. 乐观锁（Optimistic Locking）

乐观锁假设数据在大多数情况下不会发生冲突，因此允许多个事务并发地进行操作，但在提交之前会检查数据是否已被其他事务修改。通常通过一个版本号（version number）或时间戳（timestamp）来实现。

```javascript
const { Sequelize, DataTypes } = require('sequelize');
const sequelize = new Sequelize('sqlite::memory:');

const Product = sequelize.define('Product', {
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  stock: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0
  },
  version: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0
  }
}, {
  timestamps: true
});

(async () => {
  await sequelize.sync({ force: true });

  const product = await Product.create({ name: "Sample Product", stock: 100 });

  const updateStock = async (productId, decrement) => {
    const product = await Product.findByPk(productId);

    if (product.stock < decrement) {
      throw new Error('Insufficient stock');
    }

    const [affectedRows] = await Product.update(
      { stock: product.stock - decrement, version: product.version + 1 },
      { where: { id: productId, version: product.version } }
    );

    if (affectedRows === 0) {
      throw new Error('Concurrent update detected');
    }

    console.log(`Stock updated successfully`);
  };

  try {
    await updateStock(product.id, 10);
  } catch (error) {
    console.error(error.message);
  }
})();
```

### 2. 悲观锁（Pessimistic Locking）

悲观锁假设数据在大多数情况下会发生冲突，因此在读取数据时就对数据进行锁定，直到事务结束。这样可以防止其他事务同时修改相同的数据。

在 Sequelize 中，可以通过事务和锁来实现悲观锁。

```javascript
const { Sequelize, DataTypes } = require('sequelize');
const sequelize = new Sequelize('sqlite::memory:');

const Product = sequelize.define('Product', {
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  stock: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0
  }
}, {
  timestamps: true
});

(async () => {
  await sequelize.sync({ force: true });

  const product = await Product.create({ name: "Sample Product", stock: 100 });

  const updateStock = async (productId, decrement) => {
    const transaction = await sequelize.transaction();

    try {
      const product = await Product.findByPk(productId, { lock: true, transaction });

      if (product.stock < decrement) {
        throw new Error('Insufficient stock');
      }

      product.stock -= decrement;
      await product.save({ transaction });

      await transaction.commit();
      console.log(`Stock updated successfully`);
    } catch (error) {
      await transaction.rollback();
      console.error(error.message);
    }
  };

  try {
    await updateStock(product.id, 10);
  } catch (error) {
    console.error(error.message);
  }
})();
```

### 3. 数据库层面的约束

在数据库层面，可以使用数据库的事务隔离级别和锁机制来防止超卖。例如，使用 `SERIALIZABLE` 隔离级别可以确保事务按顺序执行，避免并发问题。

```javascript
const { Sequelize, DataTypes } = require('sequelize');
const sequelize = new Sequelize('sqlite::memory:', {
  isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE
});

const Product = sequelize.define('Product', {
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  stock: {
    type: DataTypes.INTEGER,
    allowNull: false,
    defaultValue: 0
  }
}, {
  timestamps: true
});

(async () => {
  await sequelize.sync({ force: true });

  const product = await Product.create({ name: "Sample Product", stock: 100 });

  const updateStock = async (productId, decrement) => {
    const transaction = await sequelize.transaction();

    try {
      const product = await Product.findByPk(productId, { transaction });

      if (product.stock < decrement) {
        throw new Error('Insufficient stock');
      }

      product.stock -= decrement;
      await product.save({ transaction });

      await transaction.commit();
      console.log(`Stock updated successfully`);
    } catch (error) {
      await transaction.rollback();
      console.error(error.message);
    }
  };

  try {
    await updateStock(product.id, 10);
  } catch (error) {
    conso...