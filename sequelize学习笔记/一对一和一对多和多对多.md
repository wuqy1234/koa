wu qy, [2024/6/14 10:59]

### sequelize中,多对多关联使用add,一对一关联使用set,一对多使用什么方法呢?

mybot899, [2024/6/14 10:59]
在 Sequelize 中，处理一对多关联时，通常使用 set 方法来设置关联，也可以使用 add 方法来添加关联。具体的使用方法取决于你是在一对多关联的哪一端进行操作。

假设你有两个模型 User 和 Post，其中一个用户可以有多个帖子（即一对多关系）。

首先，定义你的模型：

```js
const { Sequelize, DataTypes } = require('sequelize');
const sequelize = new Sequelize('database', 'username', 'password', {
  dialect: 'mysql'
});

const User = sequelize.define('User', {
  name: DataTypes.STRING
});

const Post = sequelize.define('Post', {
  title: DataTypes.STRING,
  content: DataTypes.TEXT
});
```


然后，定义一对多的关联：

```js
User.hasMany(Post);
Post.belongsTo(User);
```




### 在一对多关系的“多”端（Post）使用 setUser 方法

```js
(async () => {
  await sequelize.sync({ force: true });

  const user = await User.create({ name: 'Alice' });
  const post = await Post.create({ title: 'First Post', content: 'This is the content' });

  // 在 Post 端设置关联
  await post.setUser(user);

  const posts = await Post.findAll({ include: User });
  console.log(JSON.stringify(posts, null, 2));
})();
```




### 在一对多关系的“一”端（User）使用 addPost 方法

```js
(async () => {
  await sequelize.sync({ force: true });

  const user = await User.create({ name: 'Alice' });
  const post = await Post.create({ title: 'First Post', content: 'This is the content' });

  // 在 User 端添加关联
  await user.addPost(post);

  const users = await User.findAll({ include: Post });
  console.log(JSON.stringify(users, null, 2));
})();
```




### 在一对多关系的“一”端（User）使用 setPosts 方法

你也可以使用 setPosts 方法一次性设置多个关联：

```js
(async () => {
  await sequelize.sync({ force: true });

  const user = await User.create({ name: 'Alice' });
  const post1 = await Post.create({ title: 'First Post', content: 'This is the content' });
  const post2 = await Post.create({ title: 'Second Post', content: 'This is more content' });

  // 在 User 端设置多个关联
  await user.setPosts([post1, post2]);

  const users = await User.findAll({ include: Post });
  console.log(JSON.stringify(users, null, 2));
})();
```


总结一下：
- 多对多关联：使用 add 方法，例如 addProject。
- 一对一关联：使用 set 方法，例如 setProfile。
- 一对多关联：在“多”端使用 set 方法，例如 setUser，在“一”端使用 add 方法，例如 addPost，或者使用 set 方法，例如 setPosts。





### 多对多

这段代码使用了 Sequelize，一个基于 Node.js 的 ORM（对象关系映射）库，用来定义和关联三个模型：`Movie`（电影）、`Actor`（演员）和 `ActorMovies`（演员电影表）。下面是对这段代码的详细解读：

1. **定义 `Movie` 模型**：

   ```javascript
   const Movie = sequelize.define('Movie', { name: DataTypes.STRING });
   ```

   这行代码定义了一个名为 `Movie` 的模型，包含一个 `name` 属性，它的数据类型是 `STRING`。

2. **定义 `Actor` 模型**：

   ```javascript
   const Actor = sequelize.define('Actor', { name: DataTypes.STRING });
   ```

   这行代码定义了一个名为 `Actor` 的模型，包含一个 `name` 属性，它的数据类型是 `STRING`。

3. **定义 `ActorMovies` 模型**：

   ```javascript
   const ActorMovies = sequelize.define('ActorMovies', {
     //创建外键：
     MovieId: {
       type: DataTypes.INTEGER,
     // 这是对另一个模型的参考 ,references(意思为参考) 
       references: {
         model: Movie, // 'Movies' 可以使用MovieId外键
         key: 'id'     // 这是引用模型的列名
       }
     },
     ActorId: {
       type: DataTypes.INTEGER,
       references: {
         model: Actor, // 'Actors' 可以使用ActorId外键
         key: 'id'	    // 这是引用模型的列名
       }
     }
   });
   ```

   这段代码定义了一个名为 `ActorMovies` 的模型，它包含两个属性：

   - `MovieId`：整数类型，引用 `Movie` 模型的 `id` 属性。
   - `ActorId`：整数类型，引用 `Actor` 模型的 `id` 属性。

   这个模型用来表示电影和演员之间的多对多关系。

4. **定义 `Movie` 和 `Actor` 之间的多对多关系**：

   ```javascript
   Movie.belongsToMany(Actor, { through: ActorMovies });
   Actor.belongsToMany(Movie, { through: ActorMovies });
   ```

   这两行代码通过 `ActorMovies` 模型定义了 `Movie` 和 `Actor` 之间的多对多关系。具体来说：

   - `Movie.belongsToMany(Actor, { through: ActorMovies })` 表示一个电影可以有多个演员。
   - `Actor.belongsToMany(Movie, { through: ActorMovies })` 表示一个演员可以参演多部电影。

通过这段代码，Sequelize 将会在数据库中创建三个表：`Movies`、`Actors` 和 `ActorMovies`，并通过 `ActorMovies` 表来管理电影和演员之间的多对多关系。





```javascript
const foo = await Foo.create({ name: 'the-foo' });
const bar1 = await Bar.create({ name: 'some-bar' });
const bar2 = await Bar.create({ name: 'another-bar' });
await foo.setBar(bar1);
console.log((await foo.getBar()).name);
```

### 其中的foo.getBar()括号中可以传值吗?

在 Sequelize 中，foo.getBar() 是用来获取与 foo 关联的 Bar 实例的方法。括号中确实可以传值，这些值通常是用来指定查询条件或选项的。

### 传递查询条件或选项

你可以在 getBar() 方法中传递查询条件或选项，以进一步过滤或定制查询结果。例如：

```javascript
const bar = await foo.getBar({
  where: {
    name: 'some-bar'
  }
});
```


### 示例代码

假设你有如下模型定义和关联：

```javascript
const Foo = sequelize.define('Foo', {
  name: DataTypes.STRING
});

const Bar = sequelize.define('Bar', {
  name: DataTypes.STRING
});

Foo.hasOne(Bar);
Bar.belongsTo(Foo);
```


然后你可以使用 getBar() 方法传递查询条件：

```javascript
const foo = await Foo.create({ name: 'the-foo' });
const bar1 = await Bar.create({ name: 'some-bar' });
const bar2 = await Bar.create({ name: 'another-bar' });

await foo.setBar(bar1);

// 获取与 foo 关联的 Bar 实例，并指定查询条件
const associatedBar = await foo.getBar({
  where: {
    name: 'some-bar'
  }
});

console.log(associatedBar.name); // 输出 'some-bar'
```




### 传递其他选项

除了 where 选项外，你还可以传递其他 Sequelize 查询选项，如 attributes、include、order 等。例如：

```javascript
const associatedBar = await foo.getBar({
  attributes: ['name'],
  order: [['createdAt', 'DESC']]
});
```




### 总结

foo.getBar() 方法的括号中可以传递查询条件或选项，以进一步定制查询结果。这使得你可以灵活地获取与 foo 关联的 Bar 实例，并根据需要进行过滤或排序。