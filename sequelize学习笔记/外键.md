

### 主键（Primary Key）：

- 主键是用来唯一标识表中的每一行记录的。
- 主键列中的值必须是唯一的，并且不能包含空值（NULL）。
- 主键并不是用来排序的，但因为它是唯一的，可以用于索引和快速查找记录。

### 外键（Foreign Key）：

- 外键是用来建立和强化两个表之间的关系的。
- 外键列中的值通常是另一个表的主键值，从而在两个表之间建立关联。
- 外键可以包含重复值，并且可以包含空值（NULL）。

所以，主键的主要作用是唯一标识记录，而外键的主要作用是建立表之间的关联。排序通常是通过索引或者查询时的排序条件来实现的，而不是通过主键直接实现的。





MySQL 的外键（Foreign Key）在关系型数据库中起着至关重要的作用，主要用于维护数据的完整性和一致性。外键是一个表中的字段，它引用另一个表中的主键或唯一键。通过使用外键，可以定义表之间的关系，并确保这些关系在数据操作过程中保持一致。







### 外键的主要作用

1. **维护数据完整性**：
   - **参照完整性**：外键确保引用的值必须存在于被引用的表中。例如，如果一个订单表中的客户ID是一个外键，它必须引用一个存在于客户表中的客户ID。这防止了数据孤立和不一致的情况。
   - **级联操作**：外键可以定义级联操作，如级联删除和级联更新。当被引用表中的记录被删除或更新时，引用该记录的表中的相关记录也会自动删除或更新。这有助于保持数据的一致性。

2. **防止非法数据输入**：
   - 外键约束确保只有合法的数据才能插入到表中。例如，如果一个学生表中的班级ID是一个外键，那么只有存在于班级表中的班级ID才能插入到学生表中。这防止了输入无效或不存在的班级ID。

3. **增强查询性能**：
   - 外键可以帮助优化查询，因为数据库管理系统可以利用外键关系来生成更高效的查询计划。例如，数据库可以使用外键信息来快速定位相关记录，从而提高查询性能。

4. **加强数据模型的清晰性**：
   - 外键明确了表之间的关系，使数据模型更清晰和易于理解。这对数据库设计和维护非常有帮助，有助于确保数据库结构的合理性和一致性。

### 使用外键的示例

假设有两个表：`customers` 和 `orders`，其中 `orders` 表中的 `customer_id` 字段是一个外键，引用 `customers` 表中的 `id` 字段。

```sql
-- 创建 customers 表
CREATE TABLE customers (
    id INT PRIMARY KEY,
    name VARCHAR(100) NOT NULL
);

-- 创建 orders 表
CREATE TABLE orders (
    id INT PRIMARY KEY,
    order_date DATE NOT NULL,
    customer_id INT,
    FOREIGN KEY (customer_id) REFERENCES customers(id)
);
```

在这个示例中，`orders` 表中的 `customer_id` 字段是一个外键，它引用 `customers` 表中的 `id` 字段。这确保了 `orders` 表中的每个 `customer_id` 都必须在 `customers` 表中存在。

### 级联操作示例

可以在定义外键时指定级联操作，如级联删除（CASCADE DELETE）和级联更新（CASCADE UPDATE）：

```sql
-- 创建 orders 表，添加级联删除和更新
CREATE TABLE orders (
    id INT PRIMARY KEY,
    order_date DATE NOT NULL,
    customer_id INT,
    FOREIGN KEY (customer_id) REFERENCES customers(id)
    ON DELETE CASCADE
    ON UPDATE CASCADE
);
```

在这个示例中，如果 `customers` 表中的某个 `id` 被删除或更新，对应的 `orders` 表中的记录也会自动删除或更新。

### 总结

MySQL 的外键在维护数据完整性、确保数据一致性、防止非法数据输入、优化查询性能和增强数据模型清晰性方面起着重要作用。通过合理使用外键，可以有效地管理和维护关系型数据库中的数据。







#### wu qy, [2024/6/11 21:33]

##### foreignKey: 'senderId' 是直接给外键命名，外键不会使用模型名+id的默认命名方式。

**Mail.belongsTo(Person, { as: 'sender', foreignKey: 'senderId' });别名 'sender',其实就是模型的别名,对吗?**

#### mybot899, [2024/6/11 21:33]

**是的，as: 'sender' 中的 sender 确实是关联关系的别名。在 Sequelize 中，别名用于区分同一个模型的不同关联关系，以便在查询和操作中明确指定是哪一个关联。**

### 更详细的解释

在你的例子中：


- ```js
  Mail.belongsTo(Person, { as: 'sender', foreignKey: 'senderId' });
  ```

- Mail 模型通过 belongsTo 方法与 Person 模型建立关联。


- as: 'sender' 设置了关联关系的别名为 sender。
- foreignKey: 'senderId' 指定了外键字段 senderId，用于存储发送者的 Person 实例的主键。

同样的，另一条关联关系：

Mail.belongsTo(Person, { as: 'receiver', foreignKey: 'receiverId' });


- Mail 模型通过 belongsTo 方法与 Person 模型建立了另一个关联。
- as: 'receiver' 设置了关联关系的别名为 receiver。
- foreignKey: 'receiverId' 指定了外键字段 receiverId，用于存储接收者的 Person 实例的主键。

### 使用别名的意义

别名在以下场景中特别有用：

1. 区分多个关联：

   - 如果一个模型与另一个模型有多种不同的关联关系，使用别名可以区分这些关联。例如，在你的例子中，Mail 模型与 Person 模型有两个关联，一个是 sender，另一个是 receiver。

2. 查询关联数据：

   - 在查询数据时，可以使用别名来明确指定要查询的关联关系。例如：

     ```js
      const mailWithSenderReceiver = await Mail.findOne({
      where: { id: mail1.id },
      include: [
        { model: Person, as: 'sender' },
       { model: Person, as: 'receiver' }
     ]
     });
     ```

     通过 as: 'sender' 和 as: 'receiver'，你可以在查询中明确指定要包含的关联数据。

3. 操作关联数据：

   - 在操作关联数据时，也可以使用别名。例如：

     ```js
     const sender = await mail.getSender();
     const receiver = await mail.getReceiver();
     await mail.setSender(newSender);
     await mail.setReceiver(newReceiver);
     ```

     

### 总结

是的，as: 'sender' 中的 sender 是关联关系的别名。别名用于区分同一个模型的不同关联关系，并在查询和操作中明确指定是哪一个关联。通过使用别名，你可以更灵活地管理和操作 Sequelize 模型之间的复杂关联关系。





