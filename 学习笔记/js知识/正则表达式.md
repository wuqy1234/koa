# 模型（Patterns）和修饰符（flags）

正则表达式（可叫作 “regexp”，或 “reg”）由 **模型** 和可选的 **修饰符** 组成。

```javascript
regexp = new RegExp("pattern", "flags");
regexp = /pattern/; // 没有修饰符
regexp = /pattern/gmi; // 带有修饰符 g、m 和 i（后面会讲到）
```

这两种语法之间的主要区别在于，使用斜线 `/.../` 的模式不允许插入表达式（如带有 `${...}` 的字符串模板）。它是完全静态的。

```javascript
let tag = prompt("What tag do you want to find?", "h2");
let regexp = new RegExp(`<${tag}>`); // 如果在上方输入到 prompt 中的答案是 "h2"，
则为new RegExp('<h2>');
```

> `/(\w+)\s(\w+)/`这个是字面量定义正则表达式，`new regexp('(\w+)\s(\w+)')`是构造函数方法定义正则表达式，对吗?

完全正确！在 JavaScript 中，有两种主要方法来定义正则表达式：字面量法和构造函数法。这两种方法在语法和某些细微的行为上有所不同，但它们的功能和用途是相同的。

### 字面量法

字面量法是通过斜杠（`/`）包围正则表达式模式来定义的。这种方法通常更简洁和直观。

```javascript
const regexpLiteral = /(\w+)\s(\w+)/;
```

### 构造函数法

构造函数法是通过 `RegExp` 构造函数来创建正则表达式。这种方法在需要动态生成正则表达式时非常有用。

```javascript
const pattern = `(\\w+)\\s(\\w+)`;
const regexpConstructor = new RegExp(pattern);
```

1. 转义字符：

- 在字面量法中，反斜杠用于转义特殊字符。

- 在构造函数法中，由于字符串本身也需要转义，所以需要双重转义。例如，字面量法中的 `\w` 在构造函数法中需要写成 `\\w`，因为会消耗掉一个`\`。

1. 可读性：

- 字面量法更适合于静态的正则表达式，代码更简洁。

- 构造函数法更适合于动态生成的正则表达式，尽管代码可能更复杂一些。

\### 示例对比

字面量法

```javascript
const regexpLiteral = /(\w+)\s(\w+)/;
const str = "Hello World";
const result = regexpLiteral.exec(str);

console.log(result);
// 输出: ["Hello World", "Hello", "World", index: 0, input: "Hello World"]
```

 构造函数法:

```javascript
const pattern = `(\\w+)\\s(\\w+)`;
const regexpConstructor = new RegExp(pattern);
const str = "Hello World";
const result = regexpConstructor.exec(str);

console.log(result);
// 输出: ["Hello World", "Hello", "World", index: 0, input: "Hello World"]
```

构造函数法在需要动态生成正则表达式时非常有用。例如，根据用户输入生成正则表达式：

```javascript
const word1 = "Hello";
const word2 = "World";
const pattern = `(${word1})\\s(${word2})`;
const regexpDynamic = new RegExp(pattern);
const str = "Hello World";
const result = regexpDynamic.exec(str);

console.log(result);
// 输出: ["Hello World", "Hello", "World", index: 0, input: "Hello World"]
```







## [修饰符](https://zh.javascript.info/regexp-introduction#xiu-shi-fu)

正则表达式可能有影响搜索结果的修饰符。

在 JavaScript 中，只有 6 个修饰符：

- `i`

  使用此修饰符后，搜索时不区分大小写：`A` 和 `a` 之间没有区别（请参见下面的示例）。

- `g`

  使用此修饰符后，搜索时会寻找所有的匹配项 —— 没有它，则仅返回第一个匹配项。

- `m`

  多行模式（详见 [锚点 ^ $ 的多行模式，修饰符 "m"](https://zh.javascript.info/regexp-multiline-mode)）。

  `s`

  #### 启用 “dotall” 模式，允许点 `.` 匹配换行符 `\n`（在 [字符类](https://zh.javascript.info/regexp-character-classes) 中有详细介绍）。

- `u`

  开启完整的 Unicode 支持。该修饰符能够正确处理代理对。详见 [Unicode：修饰符 "u" 和类 \p{...}](https://zh.javascript.info/regexp-unicode)。

- `y`

  粘滞（Sticky）模式，在文本中的确切位置搜索（详见 [粘性修饰符 "y"，在位置处搜索](https://zh.javascript.info/regexp-sticky)）

在 JavaScript 中创建正则表达式时，字符串应该用`引号`包裹起来。如果你直接使用 <h2>，会导致语法错误，因为这是无效的 JavaScript 语法。你需要使用引号将其包裹起来，如下所示：

```javascript
new RegExp(<h2>);//无效
new RegExp('<h2>');//有效
```


或者，你可以使用正则表达式字面量语法：

```javascript
/<h2>/;
```


这两种方式都可以正确地创建一个匹配 <h2> 标签的正则表达式。

### 示例

1. 使用 RegExp 构造函数：

```javascript
const regex = new RegExp('<h2>');
const str = '<h2>Title</h2>';
console.log(regex.test(str)); // true
```


2. 使用正则表达式字面量：

```javascript
const regex = /<h2>/;
const str = '<h2>Title</h2>';
console.log(regex.test(str)); // true
```

这样，你就可以正确地创建一个匹配 <h2> 标签的正则表达式了。





## [匹配：str.match](https://zh.javascript.info/regexp-introduction#sou-suo-strmatch)

正如前面所提到的，将正则表达式和字符串方法结合一起使用。

`str.match(regexp)` 方法在字符串 `str` 中寻找 `regexp` 的所有匹配项。

`match`是一个字符串的方法，查找匹配项，返回一个数组，把匹配到的结果放到数组中



在 JavaScript 中，index 和 input 并不是数组的内置方法，而是正则表达式匹配结果对象的一部分。当使用 String.prototype.match 方法时，如果匹配成功，返回的结果是一个数组，同时这个数组还包含一些额外的属性，包括 index 和 input。

### String.prototype.match

当使用正则表达式的全局标志（g）时，match 方法返回一个数组，包含所有匹配的子字符串，但不包括额外的属性 index 和 input。然而，当不使用全局标志时，返回的结果不仅是一个数组，还包含一些额外的属性。

### 示例解释

```javascript
let str = "We will, we will rock you";

let result = str.match(/we/ig); // 返回一个数组。

alert(result[0]);      // 输出: "We"
alert(result.length);  // 输出: 2

alert(result.index);   // 输出: undefined
alert(result.input);   // 输出: undefined
```


在这个示例中，由于使用了全局标志 g，result 只是一个包含所有匹配项的数组，不包含 index 和 input 属性。

### 不使用全局标志的示例

如果你不使用全局标志，match 方法返回的数组将包含 index 和 input 属性：

```javascript
let str = "We will, we will rock you";

let result = str.match(/we/i); // 不使用全局标志

alert(result[0]);      // 输出: "We"
alert(result.length);  // 输出: 1

alert(result.index);   // 输出: 0
alert(result.input);   // 输出: "We will, we will rock you"
```


在这个示例中，result 是一个包含匹配项的数组，并且还包含以下属性：

- index: 匹配项在原字符串中的起始索引。
- input: 原始字符串。

### 总结

- 当使用全局标志 g 时，match 方法返回一个仅包含匹配项的数组，不包含 index 和 input 属性。
- 当不使用全局标志时，返回的数组不仅包含匹配项，还包含 index 和 input 属性。

希望这能帮助你理解 index 和 input 在正则表达式匹配结果中的作用。



`match`如果没有匹配项，则返回 `null`（无论是否有修饰符 `g`）。

例如：

```javascript
let matches = "JavaScript".match(/HTML/); // = null

if (!matches.length) { // 报错:null没有length的方法
  alert("Error in the line above");
}
```

如果我们希望结果始终是一个数组，我们可以这样写：

```javascript
let matches = "JavaScript".match(/HTML/) || [];

if (!matches.length) {
  alert("No matches"); // 现在可以了
}
```



## [替换：str.replace](https://zh.javascript.info/regexp-introduction#ti-huan-strreplace)

`str.replace(regexp, replacement)` 方法使用 `replacement` 替换在字符串 `str` 中找到的 `regexp` 的匹配项（如果带有修饰符 `g` 则替换所有匹配项，否则只替换第一个）。

例如：

```javascript
// 没有修饰符 g
alert( "We will, we will".replace(/we/i, "I") ); // I will, we will

// 带有修饰符 g
alert( "We will, we will".replace(/we/ig, "I") ); // I will, I will
```

第二个参数是字符串 `replacement`。我们可以在其中使用特殊的字符组合来对匹配项进行插入：

| 符号      | 在替换字符串中的行为                                         |
| :-------- | :----------------------------------------------------------- |
| `$&`      | 插入整个匹配项                                               |
| $`        | 插入字符串中匹配项之前的字符串部分                           |
| `$'`      | 插入字符串中匹配项之后的字符串部分                           |
| `$n`      | 如果 `n` 是一个 1-2 位的数字，则插入第 n 个分组的内容，详见 [捕获组](https://zh.javascript.info/regexp-groups) |
| `$<name>` | 插入带有给定 `name` 的括号内的内容，详见 [捕获组](https://zh.javascript.info/regexp-groups) |
| `$$`      | 插入字符 `$`                                                 |

带有 `$&` 的一个示例：

```javascript
alert( "I love HTML".replace(/HTML/, "$& and JavaScript") ); // I love HTML and JavaScript
```

## [测试：regexp.test](https://zh.javascript.info/regexp-introduction#ce-shi-regexptest)

`regexp.test(str)` 方法寻找至少一个匹配项，如果找到了，则返回 `true`，否则返回 `false`。

```javascript
let str = "I love JavaScript";
let regexp = /LOVE/i;

alert( regexp.test(str) ); // true
```

在后面的章节中，我们会学习更多正则表达式，通过更多的例子，也会遇到其他的方法。

关于这些方法的完整信息请见 [正则表达式和字符串的方法](https://zh.javascript.info/regexp-methods)。



# 字符类**（Character classes）** 



最常用的是：

- `\d`（“d” 来自 “digit”）

  数字：从 `0` 到 `9` 的字符。

- `\s`（“s” 来自 “space”）

  空格符号：包括空格，制表符 `\t`，换行符 `\n` 和其他少数稀有字符，例如 `\v`、`\f` 和 `\r`。

- `\w`（“w” 来自 “word”）

  “单字”字符：`拉丁字母`或`数字`或下划线 `_`。

​    对于每个字符类，都有一个“反向类”，用相同的字母表示，但是大写的。

“反向”表示它与所有其他字符匹配，例如：

- `\D`

  非数字：除 `\d` 以外的任何字符，例如字母。

- `\S`

  非空格符号：除 `\s` 以外的任何字符，例如字母。

- `\W`

  非单字字符：除 `\w` 以外的任何字符，例如非拉丁字母或空格。

> 点 `.` 是一种特殊字符类，它与“除换行符之外的任何单个字符”匹配。



请注意，点表示“任何字符”，而不是“缺少字符”。必须有一个与之匹配的字符：

```javascript
alert( "CS4".match(/CS.4/) ); // null，没有匹配项，因为这里没有与点匹配的字符
```

### [带有修饰符 “s” 时点字符类匹配任何字符](https://zh.javascript.info/regexp-character-classes#dai-you-xiu-shi-fusshi-dian-zi-fu-lei-pi-pei-ren-he-zi-fu)

默认情况下，点与换行符 `\n` 不匹配。

例如，正则表达式 `A.B` 匹配 `A`，然后匹配 `B` 和它们之间的任何字符，除了换行符`\n`：

```javascript
alert( "A\nB".match(/A.B/) ); // null（无匹配项）
```

在很多情况下，我们希望点能够匹配“任何字符”，包括换行符。

#### `.`通配符: 点

> 在 JavaScript 的正则表达式中，`.`（点）是一个通配符，它可以匹配除换行符（`\n`、`\r`、`\u2028` 和 `\u2029`）之外的任何单个字符。如果你希望 `.` 能匹配包括换行符在内的所有字符，你需要使用修饰符 `s`（即 dotAll 模式）。

这就是修饰符 `s` 所做的事。如果有一个正则表达式具有该修饰符，那么点 `.` 能够匹配任何字符：`查看目录: 修饰符`

```javascript
alert( "A\nB".match(/A.B/s) ); // A\nB（匹配了！）
```



# Unicode：修饰符 "u" 和类 \p{...}

- 字母（Letter）L：
  - 小写（lowercase）`Ll`，
  - 修饰（modifier）`Lm`，
  - 首字母大写（titlecase）`Lt`，
  - 大写（uppercase）`Lu`，
  - 其它（other）`Lo`。

- 数字（Number）N
  - 十进制数字（decimal digit）`Nd`，
  - 字母数字（letter number）`Nl`（例如 Ⅻ —— 罗马数字 12），
  - 其它（other）`No`。
  - `Hex_Digit` 包括 16 进制数字 `0-9`，`a-f`。
- 标点符号（Punctuation）P
  - 连接符（connector）`Pc`，
  - 横杠（dash）`Pd`，
  - 起始引号（initial quote）`Pi`，
  - 结束引号（final quote）`Pf`，

- 符号（Symbol）S

  - 货币（currency）`Sc`，
  - 修饰（modifier）`Sk`，
  - 数学（math）`Sm`，
  - 其它（other）`So`。

- 分隔符（Separator）Z

  - 行（line）`Zl`，

  - 段落（paragraph）`Zp`，

  - 空格（space）`Zs`。

    

### [举例：16 进制数字](https://zh.javascript.info/regexp-unicode#ju-li-16-jin-zhi-shu-zi)

举个例子，让我们来查找 16 进制数字，写作 `xFF` 其中 `F` 是一个 16 进制的数字（0…9 或者 A…F）。

一个 16 进制数字可以表示为 `\p{Hex_Digit}`：

```javascript
let regexp = /x\p{Hex_Digit}\p{Hex_Digit}/u;

alert("number: xAF".match(regexp)); // xAF
```

### [举例：中文字符](https://zh.javascript.info/regexp-unicode#ju-li-zhong-wen-zi-fu)

让我们再来查找中文字符。

有一个 Unicode 属性 `Script`（一个书写系统），这个属性可能有一个值：`Cyrillic`、`Greek`、`Arabic`、`Han`（中文）等等，[这里是一个完整的列表](https://en.wikipedia.org/wiki/Script_(Unicode))。

要在给定的书写系统中查找字符，我们需要使用 `Script=<value>`，例如对于西里尔字母：`\p{sc=Cyrillic}`，中文象形文字：`\p{sc=Han}`，等等。

```javascript
let regexp = /\p{sc=Han}/gu; // 返回中文象形文字

let str = `Hello Привет 你好 123_456`;

alert( str.match(regexp) ); // 你,好
```

### [举例：货币](https://zh.javascript.info/regexp-unicode#ju-li-huo-bi)

表示货币的字符，例如 `$`、`€` 和 `¥`，具有 Unicode 属性 `\p{Currency_Symbol}`，缩写为 `\p{Sc}`。

让我们用它来查找格式为“货币，接着是一个数字”的价格：

```javascript
let regexp = /\p{Sc}\d/gu;

let str = `Prices: $2, €1, ¥9`;

alert( str.match(regexp) ); // $2,€1,¥9
```

稍后，在文章 [量词 +, *, ? 和 {n}](https://zh.javascript.info/regexp-quantifiers) 中我们将学习如何查找包含很多位的数字。



## [总结](https://zh.javascript.info/regexp-unicode#zong-jie)

修饰符 `u` 表示启用正则表达式中对 Unicode 的支持。

这意味着两件事：

1. 4 个字节长的字符被以正确的方式处理：被看成单个字符，而不是 2 个 2 字节长的字符。
2. Unicode 属性可以被用于查找：`\p{…}`。

有了 unicode 属性我们可以查找给定语言中的词，特殊字符（引用，货币）等等。





# 锚点：字符串开始 ^ 和末尾 $

举个例子，让我们测试一下文本是否以 `Mary` 开头：

```javascript
let str1 = "Mary had a little lamb";
alert( /^Mary/.test(str1) ); // true
```

该模式 `^Mary` 表示：字符串开始，紧接着就是 “Mary”。

与此类似，我们可以用 `snow$` 来测试文本是否以 `snow` 结尾：

```javascript
let str1 = "it's fleece was white as snow";
alert( /snow$/.test(str1) ); // true
```

在以上这些特殊的例子中我们实际上可以用 `startsWith/endsWith` 来代替。正则表达式应该被用于更加复杂的测试。

```javascript
let str1 = "Mary had a little lamb";
alert( str1.startsWith('Mary') ); // true
```

```javascript
let str1 = "it's fleece was white as snow";
alert(str1.endsWith('snow') ); // true
```

## [测试完全匹配](https://zh.javascript.info/regexp-anchors#ce-shi-wan-quan-pi-pei)

这两个锚点 `^...$` 放在一起通常被用于测试一个字符串是否完全匹配一个模式。例如，检查用户输入的格式是否正确。

让我们测试一个字符串是否是 `12:34` 格式的时间。即，两位数，然后是一个冒号，接着是另一个两位数。

用正则表达式来表示就是 `\d\d:\d\d`：

```javascript
let goodInput = "12:34";
let badInput = "12:345";

let regexp = /^\d\d:\d\d$/;
alert( regexp.test(goodInput) ); // true
alert( regexp.test(badInput) ); // false
```

在这个例子中 `\d\d:\d\d` 所对应的匹配项必须正好在文本 `^` 的开头之后开始，并且结尾 `$` 必须紧跟其后。

整个字符串必须完全符合这个格式。如果其中有任何偏差或额外的字符，结果将为 `false`。



# 锚点 ^ $ 的多行模式，修饰符 "m"

多行模式由修饰符 `m` 启用。

它只影响 `^` 和 `$` 的行为。

在多行模式下，它们不仅仅匹配文本的开始与末尾，还匹配每一行的开始与末尾。



# 词边界：\b

例如，可以在 `Hello, Java!` 中找到 `\bJava\b` 的匹配项，其中 `Java` 是一个独立的单词，而在 `Hello, JavaScript!` 中则不行。

```javascript
alert( "Hello, Java!".match(/\bJava\b/) ); // Java
alert( "Hello, JavaScript!".match(/\bJava\b/) ); // null
```

 `\bHello\b` 会匹配，但 `\bHell\b` 不会匹配（因为在 `l` 之后没有单词边界），`Java!\b` 也不会匹配（因为感叹号不是单词字符 `\w`，所以其后没有词边界）。

```javascript
alert( "Hello, Java!".match(/\bHello\b/) ); // Hello
alert( "Hello, Java!".match(/\bJava\b/) );  // Java
alert( "Hello, Java!".match(/\bHell\b/) );  // null（无匹配项）
alert( "Hello, Java!".match(/\bJava!\b/) ); // null（无匹配项）
```

`\b` 既可以用于单词，也可以用于数字。

例如，模式 `\b\d\d\b` 查找独立的两位数。换句话说，它查找的是两位数，其周围是与 `\w` 不同的字符，例如空格或标点符号（或文本开头/结尾）。

```javascript
alert( "1 23 456 78".match(/\b\d\d\b/g) ); // 23,78
alert( "12,34,56".match(/\b\d\d\b/g) ); // 12,34,56
```

# 转义，特殊字符

正如我们所看到的，反斜杠 `\` 用于表示字符类，例如 `\d`。所以它是正则表达式中的一个特殊字符（就像在常规字符串中一样）。

还存在其它特殊字符，这些字符在正则表达式中有特殊的含义，例如 `[ ] { } ( ) \ ^ $ . | ? * +`。它们用于执行更强大的搜索。

## [转义](https://zh.javascript.info/regexp-escaping#zhuan-yi)

假如我们想要找到一个点号 `.`。

要将特殊字符用作常规字符，请在其前面加上反斜杠：`\.`。

这就是所谓的“转义字符”。

例如：

> 点 `.` 是一种特殊字符类，它与“除换行符之外的任何单个字符”匹配。要找到点，就需要转义。

```javascript
alert( "Chapter 5.1".match(/\d\.\d/) ); // 5.1（匹配了！）
alert( "Chapter 511".match(/\d\.\d/) ); // null（寻找一个真正的点 \.）
```

括号也是特殊字符，所以如果我们想要查找它们，我们应该使用 `\(`。下面的例子会查找一个字符串 `"g()"`：

```javascript
alert( "function g()".match(/g\(\)/) ); // "g()"
```

如果我们想查找反斜杠 `\`，我们就应该使用两个反斜杠：

```javascript
alert( "1\\2".match(/\\/) ); // '\'
```



## [一个斜杠](https://zh.javascript.info/regexp-escaping#yi-ge-xie-gang)

斜杠符号 `'/'` 并不是一个特殊字符，但是它被用于在 Javascript 中开启和关闭正则匹配：`/...pattern.../`，所以我们也应该转义它。

下面是搜索斜杠 `'/'` 的表达式：

```javascript
alert( "/".match(/\//) ); // '/'
```

从另一个方面看，如果我们没使用 `/.../`，而是使用另一种 `new RegExp` 的方式创建正则表达式，则不需要转义斜杠：

```javascript
alert( "/".match(new RegExp("/")) ); // 找到了 /
```



```javascript
let reg = new RegExp("\d\.\d");
alert( "Chapter 5.1".match(reg) ); // null
```

反斜杠被字符串“消耗”了

```javascript
alert("\d\.\d"); // d.d 其中new RegExp("\d\.\d")也是返回的是d.d
```

所以需要多加一个'\\'

```javascript
let regStr = "\\d\\.\\d";
alert(regStr); // \d\.\d（现在对了）
//当将字符串传递给给 new RegExp 时，我们需要双反斜杠 \\，因为字符串引号会消耗一个反斜杠。
let regexp = new RegExp(regStr);

alert( "Chapter 5.1".match(regexp) ); // 5.1
//或者
let regStr_1 = /\d\.\d/;//不要加双引号, "/\d\.\d/"是在定义一个字符串
alert( "Chapter 5.1".match(regStr_1) ); // 5.1

```



# 集合和范围 [...]

在方括号 `[…]` 中的几个字符或者字符类表示“搜索给定字符中的任意一个”。

```javascript
alert( "Exception 0xAF".match(/x[0-9A-F][0-9A-F]/g) ); // xAF
```

`[0-9A-F] `中有两个范围：它搜索一个字符，该字符要么是在 0 到 9 范围内的数字，要么是从 A 到 F 的字母。

如果我们还想查找小写字母，则可以添加范围 `a-f`：`[0-9A-Fa-f]`。或添加标志 `i`。

我们也可以在 `[…]` 中使用字符类。

例如，如果我们想查找单词字符 `\w` 或连字符 `-`(如:`a-`，即字母后面的连接符号`-`)，则集合可以写为 `[\w-]`。

也可以组合多个类，例如 `[\s\d]` 表示“空格字符或数字”。

例如：

- **\d** —— 和 `[0-9]` 相同，
- **\w** —— 和 `[a-zA-Z0-9_]` 相同，
- **\s** —— 和 `[\t\n\v\f\r ]` 外加少量罕见的 Unicode 空格字符相同。

 `\w` 是简写的 `[a-zA-Z0-9_]`大小写字母、数字和下划线。



我们可以编写一个更通用的模式，该模式可以查找任何语言中的单词字符。借助 Unicode 属性很容易实现：`[\p{Alpha}\p{M}\p{Nd}\p{Pc}\p{Join_C}]`。

让我们理解一下。类似于 `\w`，我们正在制作一组属于我们自己的包含具有以下 Unicode 属性的字符：

- `Alphabetic` (`Alpha`) —— 字母，
- `Mark` (`M`) —— 音调，
- `Decimal_Number` (`Nd`) —— 数字，
- `Connector_Punctuation` (`Pc`) —— 下划线 `'_'` 和类似的字符，
- `Join_Control` (`Join_C`) —— 两个特殊代码 `200c` 和 `200d`，用于连字，例如阿拉伯语。

使用示例：

```javascript
let regexp = /[\p{Alpha}\p{M}\p{Nd}\p{Pc}\p{Join_C}]/gu;

let str = `Hi 你好 12`;

// 找出所有字母和数字：
alert( str.match(regexp) ); // H,i,你,好,1,2
```

`Alphabetic` 是一个 Unicode 属性，用于匹配所有具有字母属性的字符。这包括所有语言中的字母字符，而不仅仅是拉丁字母。

以下是如何在 JavaScript 中使用 Unicode 属性转义来匹配任意字母字符的示例：

```javascript
let regex = /\p{Alphabetic}/gu;
let text = "Hello, こんにちは, 你好, Привет, مرحبا";

let matches = text.match(regex);

console.log(matches); // 输出: ["H", "e", "l", "l", "o", "こ", "ん", "に", "ち", "は", "你", "好", "П", "р", "и", "в", "е", "т", "م", "ر", "ح", "ب", "ا"]
```

在这个例子中，正则表达式 `\p{Alphabetic}` 匹配了字符串中的所有字母字符，包括来自不同语言的字符。



## [排除范围](https://zh.javascript.info/regexp-character-sets-and-ranges#pai-chu-fan-wei)

除了普通的范围匹配，还有像这样 `[^…]` 的“排除”范围匹配。

通过在开头添加插入符号 `^` 来表示匹配所有 **除了给定的字符** 之外的任意字符。

例如：

- `[^aeyo]` —— 匹配除了 `'a'`、`'e'`、`'y'` 或 `'o'` 之外的任何字符。

- `[^0-9]` —— 匹配除了数字之外的任何字符，与 `\D` 作用相同。

- `[^\s]` —— 匹配任何非空格字符，与 `\S` 作用相同。

  下面的示例搜索除了字母、数字和空格之外的任何字符：

  ```javascript
  alert( "alice15@gmail.com".match(/[^\d\sA-Z]/gi) ); // @ .
  alert( "alice15@gmail.com".match(/[^\d\sA-Za-z]/g) ); // @ .
  ```



## […\] 中的转义

在`/.../`和`new RegExp(regStr)`  中 `\.`查找小数点 或 `\\`查找反斜杠，等等通常需要转义。

在方括号中，我们可以使用绝大多数特殊字符而无需转义：

- 符号 `. + ( )` 无需转义。
- 在开头或结尾（未定义范围，如:`a-z`）的连字符 `-` 无需转义。如: `/[-().^+]/g``;`。
- 插入符号 `^` 仅在开头会被转义（表示排除）。
- 右方括号 `]` 总是会被转义（如果我们需要寻找那个符号）。

在下面的示例中，正则表达式 `[-().^+]` 查找 `-().^+` 中的任何字符：

```javascript
// 不需要转义
let reg = /[-().^+]/g;

alert( "1 + 2 - 3".match(reg) ); // 匹配 +，-
```

……但是如果你为了“以防万一”转义了它们，这也不会有任何问题：

```javascript
// 转义其中的所有字符
let reg = /[\-\(\)\.\^\+]/g;

alert( "1 + 2 - 3".match(reg) ); // 仍能正常工作：+，-
```

## [范围和修饰符 “u”](https://zh.javascript.info/regexp-character-sets-and-ranges#fan-wei-he-xiu-shi-fu-u)

如果集合中有代理对（surrogate pairs），则需要标志 `u` 才能使它们正常工作。

例如，让我们在字符串 `𝒳` 中查找 `[𝒳𝒴]`：

如果我们添加了修饰符 `u`，那么行为就正常了：

```javascript
alert( '𝒳'.match(/[𝒳𝒴]/u) ); // 𝒳
```

带有修饰符 `u` 时，该模式就可以正常匹配了：

```javascript
// 查找从 𝒳 到 𝒵 的字符
alert( '𝒴'.match(/[𝒳-𝒵]/u) ); // 𝒴
```



# 量词 +, *, ? 和 {n}

确切的位数：`{5}`

`\d{5}` 表示 5 位数，与 `\d\d\d\d\d` 相同。

我们可以添加 `\b` 来排除位数更多的数字：`\b\d{5}\b`。

要查找 3-5 位的数字，我们可以将限制写在花括号中：`\d{3,5}`

 `\d{3,}` 查找数字的个数大于等于 `3`的数字：

```javascript
alert( "I'm not 12, but 345678 years old".match(/\d{3,}/) ); // "345678"
```

`+`代表“一个或多个”，与 `{1,}` 相同。

例如，`\d+` 用来查找所有数字：

```javascript
let str = "+7(903)-123-45-67";

alert( str.match(/\d+/g) ); // 7,903,123,45,67
```

`?`代表“零个或一个”，与 `{0,1}` 相同。

我们在模式开头附近添加了一个可选的斜杠 `/?`。必须用一个反斜杠转义它，否则 JavaScript 会认为它是这个模式的结束符。

`/<\/?[a-z][a-z0-9]*>/` 其中`\/?`表示0个或一个`/`

```javascript
alert( "<h1>Hi!</h1>".match(/<\/?[a-z][a-z0-9]*>/gi) ); // <h1>, </h1>这里的问号跟在"/"后面,表示有或没有斜杆。
```

```javascript
let str = "Should I write color or colour?";
alert( str.match(/colou?r/g) ); // color, colour 这里的问号更像占位符,有或者没有字符或其它
```

`*`代表“零个及以上”，与 `{0,}` 相同。

```javascript
alert( "100 10 1".match(/\d0*/g) ); // 100, 10, 1
```

将其与 `+`（一个或更多）做比较：

```javascript
alert( "100 10 1".match(/\d0+/g) ); // 100, 10
// 1 没有被匹配出来，因为 0+ 要求至少有一个 0
```

# 贪婪量词和惰性量词

让我们试一下：我们想要的是 "witch" 和 "broom"

```javascript
let regexp = /".+"/g;//表示任意的字符,加号表示多个。

let str = 'a "witch" and her "broom" is one';

alert( str.match(regexp) ); //结果 "witch" and her "broom",不尽如人意。
```

它没有找到匹配项 `"witch"` 和 `"broom"`，而是找到：`"witch" and her "broom"`。这就是`贪婪量词`的贪婪特性了。

先是匹配到了`"`引号，然后是通配符`.`进行匹配，一直匹配到了`e`(到了末尾了)，发现最后的一个引号还没匹配，所以搜索引擎开始回溯，然后回溯到了`broom`后面的引号，所以返回`"witch" and her "broom"`。

`惰性模式`:惰性模式中的量词与贪婪模式中的是相反的。它表示：“重复最少的次数”。通过在量词后面添加一个问号 `'?'` 来启用它，这样匹配模式就变成了 `*?` 或 `+?`。

将 `'?'` 变成 `??`。通常问号 `?` 本身就是一个量词（0 或 1），但如果将其放到 **另一个量词（甚至是它自己）后面**，就会有不同的含义 —— 它将匹配的模式从贪婪转为惰性。

正则表达式 `/".+?"/g` 能够按预期工作了：它找到了 `"witch"` 和 `"broom"`：

```javascript
let regexp = /".+?"/g;

let str = 'a "witch" and her "broom" is one';

alert( str.match(regexp) ); // "witch", "broom"
```

懒惰模式，先是匹配到了`"`引号，然后是通配符`.`进行匹配，不过通配符匹配一次就开始匹配下一个引号，发现下一个不是引号，所以又开始匹配通配符，再又匹配引号，再通配符，一直循环下去，直到找到了下一个引号。由于开启了全局模式，当一个匹配成功了，会开始下一个匹配。

## [替代懒惰模式的方法](https://zh.javascript.info/regexp-greedy-and-lazy#ti-dai-fang-fa)

不启用惰性模式的情况下使用正则表达式 `"[^"]+"` 找到带引号的字符串：

```javascript
let regexp = /"[^"]+"/g;

let str = 'a "witch" and her "broom" is one';

alert( str.match(regexp) ); // "witch", "broom"
```



例如，我们想要找到 `<a href="..." class="doc">` 形式的带有任意 `href` 的链接。

验证一下：`/<a href=".*" class="doc">/g`。`贪婪模式`

```javascript
let str = '...<a href="link" class="doc">...';
let regexp = /<a href=".*" class="doc">/g;

// 有效！
alert( str.match(regexp) ); // <a href="link" class="doc">
```

……但如果文本中有多个链接呢？`贪婪模式`

```javascript
let str = '...<a href="link1" class="doc">... <a href="link2" class="doc">...';
let regexp = /<a href=".*" class="doc">/g;

// 一个匹配项中有两个链接，这是通配符匹配到了尾部再回溯带来的效果。
alert( str.match(regexp) ); // <a href="link1" class="doc">... <a href="link2" class="doc">
```



让我们启用惰性量词 `.*?` 来修改模式：`懒惰模式`

```javascript
let str = '...<a href="link1" class="doc">... <a href="link2" class="doc">...';
let regexp = /<a href=".*?" class="doc">/g;

// 正确了！
alert( str.match(regexp) ); // <a href="link1" class="doc">, <a href="link2" class="doc">
```



……但是让我们用另外一个文本来测试看看：

```javascript
let str = '...<a href="link1" class="wrong">... <p style="" class="doc">...';
let regexp = /<a href=".*?" class="doc">/g;

// 错误的匹配！贪婪模式，通配符每匹配一个字符就查找一次 " class="doc"> 
alert( str.match(regexp) ); // <a href="link1" class="wrong">... <p style="" class="doc">
```

所以，我们需要模式寻找 `<a href="...something..." class="doc">`，但贪婪模式和惰性模式都有问题。

正确的变体可以是这样的：`href="[^"]*"`。它会获取 `href` 特性中的所有字符直到最近的引号，正好符合我们的需求。

举个例子：

```javascript
let str1 = '...<a href="link1" class="wrong">... <p style="" class="doc">...';
let str2 = '...<a href="link1" class="doc">... <a href="link2" class="doc">...';
//[^"]*任意0个或多个非引号的字符，匹配到了引号，再是空格,再是class="doc">
let regexp = /<a href="[^"]*" class="doc">/g;

// 有效！
alert( str1.match(regexp) ); // null，无匹配项，这是对的
alert( str2.match(regexp) ); // <a href="link1" class="doc">, <a href="link2" class="doc">
```



# 捕获组

模式的一部分可以用括号括起来 `(...)`。这被称为“捕获组。

不带括号，模式 `go+` 表示 `g` 字符，其后 `o` 重复一次或多次。例如 `goooo` 或 `gooooooooo`。

括号将字符组合，所以 `(go)+` 匹配 `go`，`gogo`，`gogogo`等。



```javascript
let str = '<h1>Hello, world!</h1>';

let tag = str.match(/<(.*?)>/);

alert( tag[0] ); // <h1>
alert( tag[1] ); // h1
```

1. 在索引 `0` 处：完整的匹配项。
2. 在索引 `1` 处：第一个括号的内容。
3. 在索引 `2` 处：第二个括号的内容。
4. ……等等……

### [嵌套组](https://zh.javascript.info/regexp-groups#qian-tao-zu)

```javascript
let str = '<span class="my">';
先返回第一个括号`()`包裹`([a-z]+)\s*([^>]*)`的内容，平级的括号从左到右。
let regexp = /<(([a-z]+)\s*([^>]*))>/;

let result = str.match(regexp);
alert(result[0]); // <span class="my">
alert(result[1]); // span class="my"
alert(result[2]); // span
alert(result[3]); // class="my"
```

### [可选组](https://zh.javascript.info/regexp-groups#ke-xuan-zu)

即使组是可选的并且在匹配项中不存在（例如，具有量词 `(...)?`），也存在相应的 `result` 数组项，并且等于 `undefined`。

例如，让我们考虑正则表达式 `a(z)?(c)?`。它查找 `"a"`，后面是可选的 `"z"`，然后是可选的 `"c"`。

如果我们在单个字母的字符串上运行 `a`，则结果为：

```javascript
let match = 'a'.match(/a(z)?(c)?/);

alert( match.length ); // 3
alert( match[0] ); // a（完整的匹配项）
alert( match[1] ); // undefined
alert( match[2] ); // undefined
```



对字符串 `ac` 的匹配：

```javascript
let match = 'ac'.match(/a(z)?(c)?/)

alert( match.length ); // 3
alert( match[0] ); // ac（完整的匹配项）
alert( match[1] ); // undefined, 因为没有 (z)? 的匹配项
alert( match[2] ); // c
```

数组长度依然是：`3`。但没有组 `(z)?` 的匹配项，所以结果是 `["ac", undefined, "c"]`。





## [带有组搜索所有匹配项：matchAll](https://zh.javascript.info/regexp-groups#dai-you-zu-sou-suo-suo-you-pi-pei-xiang-matchall)

例如：

```javascript
let results = '<h1> <h2>'.matchAll(/<(.*?)>/gi);

// results —— 不是数组，而是一个迭代对象
alert(results); // [object RegExp String Iterator] RegExp正则表达式

alert(results[0]); // undefined (*)

results = Array.from(results); // 让我们将其转换为数组,可迭代对象都可以转换为数组。

alert(results[0]); // <h1>,h1（第一个标签）
alert(results[1]); // <h2>,h2（第二个标签）
```

我们可以看到，第一个区别非常重要，如 `(*)` 行所示。我们无法获得 `results[0]` 的匹配项，因为该对象并不是伪数组，而是可迭代对象。我们可以使用 `Array.from` 把它变成一个真正的 `Array`。 [可迭代对象](C:\Users\86166\Desktop\koa-1\sequelize学习笔记\js知识\可迭代对象.md)

如果我们只需要遍历结果，则没有使用`Array.from`方法的必要：

```javascript
let results = '<h1> <h2>'.matchAll(/<(.*?)>/gi);

for(let result of results) {
  alert(result);
  // 第一个 alert：<h1>,h1
  // 第二个：<h2>,h2
}
```

……或使用解构：

```javascript
let [tag1, tag2] = '<h1> <h2>'.matchAll(/<(.*?)>/gi);
```

`matchAll` 返回的每个匹配项，与不带修饰符 `g` 的 `match` 所返回的格式相同：具有额外 `index`（字符串中的匹配索引）属性和 `input`（源字符串）的数组：

```javascript
let results = '<h1> <h2>'.matchAll(/<(.*?)>/gi);

let [tag1, tag2] = results;

alert( tag1[0] ); // <h1>
alert( tag1[1] ); // h1
alert( tag1.index ); // 0
alert( tag1.input ); // <h1> <h2>
```



如果你不使用全局标志`g`，match 方法返回的数组将包含 index 和 input 属性：

```javascript
let str = "We will, we will rock you";

let result = str.match(/we/i); // 不使用全局标志

alert(result[0]);      // 输出: "We"
alert(result.length);  // 输出: 1

alert(result.index);   // 输出: 0 ;如果str.match(/we/ig)带了g,则返回null
alert(result.input);   // 输出: "We will, we will rock you" ;如果str.match(/we/ig)带了g,则返回null
```

## [命名组](https://zh.javascript.info/regexp-groups#ming-ming-zu)

给括号命名

在左括号后紧跟着放置 `?<name>` 即可完成对括号的命名。

例如，让我们查找 “year-month-day” 格式的日期：

```javascript
let dateRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/;
let str = "2019-04-30";

let groups = str.match(dateRegexp).groups;

alert(groups.year); // 2019
alert(groups.month); // 04
alert(groups.day); // 30
```

正如你所看到的，匹配的组在 `.groups` 属性中。

要查找所有日期，我们可以添加修饰符 `g`。

我们还需要 `matchAll` 以获取完整的组匹配：

```javascript
let dateRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/g;

let str = "2019-10-30 2020-01-01";

let results = str.matchAll(dateRegexp);

for(let result of results) {
  let {year, month, day} = result.groups;
    // 第一个：30.10.2019
    // 第二个：01.01.2020
  alert(`${day}.${month}.${year}`);
  
}
```

## [替换中的捕获组](https://zh.javascript.info/regexp-groups#ti-huan-zhong-de-bu-huo-zu)

 `str.replace(regexp, replacement)` 允许我们在 `replacement` 字符串中使用括号中的内容。这使用 `$n` 来完成，其中 `n` 是组号。

例如，

```javascript
let str = "John Bull";
let regexp = /(\w+) (\w+)/;

alert( str.replace(regexp, '$2, $1') ); // Bull, John
```

对于命名的括号，引用为 `$<name>`。

例如，让我们将日期格式从 “year-month-day” 更改为 “day.month.year”：

```javascript
let regexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/g;

let str = "2019-10-30, 2020-01-01";

alert( str.replace(regexp, '$<day>.$<month>.$<year>') );
// 30.10.2019, 01.01.2020
```

## [非捕获组 ?:](https://zh.javascript.info/regexp-groups#fei-bu-huo-zu)

可以通过在开头添加 `?:` 来排除组。

在下面的示例中，我们仅将名称 `John` 作为匹配项：

```javascript
let str = "Gogogo John!";

// ?: 从捕获组中排除 'go'
let regexp = /(?:go)+ (\w+)/i;

let result = str.match(regexp);

alert( result[0] ); // Gogogo John（完整的匹配项）
alert( result[1] ); // John
alert( result.length ); // 2（在数组中没有其他数组项）
```

# 模式中的反向引用：\N 和 \k<name>

比如想匹配到字符串 `"She's the one!"` 时，使用`['"](.*?)['"]`，便会导致不正确的匹配。

```javascript
let str = `He said: "She's the one!".`;

let regexp = /['"](.*?)['"]/g;

// 不是我们想要的结果
alert( str.match(regexp) ); // "She'
```

正如我们所看到的，该模式找到了一个开头的引号 `"`，然后文本被匹配，直到另一个引号 `'`，该匹配结束。

为了确保模式查找的结束引号与开始的引号完全相同，我们可以将其包装到捕获组中并对其进行反向引用：`(['"])(.*?)\1`。

这是正确的代码：

```javascript
let str = `He said: "She's the one!".`;

let regexp = /(['"])(.*?)\1/g;

alert( str.match(regexp) ); // "She's the one!"
```

现在可以了！正则表达式引擎会找到第一个引号 `(['"])` 并记住其内容。那是第一个捕获组。

在模式中 `\1` 表示“找到与第一组相同的文本”，在我们的示例中为完全相同的引号。

与此类似，`\2` 表示第二组的内容，`\3` —— 第三分组，依此类推。

> **不要搞混了：在模式中用 `\1`，在替换项中用：`$1`**
>
> 在替换字符串中我们使用美元符号：`$1`，而在模式中 —— 使用反斜杠 `\1`。

## [按命名反向引用：\k<name>

如果一个正则表达式中有很多括号，给它们起个名字会便于引用。

要引用命名的捕获组，我们可以使用：`\k<name>`。

在下面的示例中，带引号的组被命名为 `?<quote>`，因此反向引用为 `\k<quote>`：

```javascript
let str = `He said: "She's the one!".`;

let regexp = /(?<quote>['"])(.*?)\k<quote>/g;

alert( str.match(regexp) ); // "She's the one!"
```



# 选择 (OR) |

例如，我们想要找出编程语言：HTML、PHP、Java 或 JavaScript。

对应的正则表达式为：`html|php|java(script)?`。

用例如下：

```javascript
let regexp = /html|php|css|java(script)?/gi;//中的 `java(script)?` 表示匹配 "java" 或 "javascript"。

let str = "First HTML appeared, then CSS, then JavaScript";

alert( str.match(regexp) ); // 'HTML', 'CSS', 'JavaScript'
```

例如：

- `gr(a|e)y` 等同于 `gr[ae]y`。
- `gra|ey` 表示 `gra` 或 `ey`。

要将选择应用于模式中一部分内容的选择，我们可以将其括在括号中：

- `I love HTML|CSS` 匹配 `I love HTML` 或 `CSS`。
- `I love (HTML|CSS)` 匹配 `I love HTML` 或 `I love CSS`。

hh:mm` 的时间字符串，例如 `12:00`。但是简单的 `\d\d:\d\d` 太模糊了。它也会匹配 `25:99`（因为 25 和 99 都与模式匹配，但这不是有效的时间）。

应用更精细的匹配

- 如果第一位数是 `0` 或 `1`，那么下一位数可以是任何数值：`[01]\d`。
- 如果第一位数是 `2`，那么下一位数必须是 `[0-3]`。
- 不允许其他的首位数。

编写这两种变体：`[01]\d|2[0-3]`。

分钟必须为从 `00` 到 `59` 的数。写成正则表达式即为 `[0-5]\d`：第一个数字 `0-5`，然后是任何数字。

如果我们将小时和分钟的正则表达式组合在一起，我们会得到：`[01]\d|2[0-3]:[0-5]\d`

我们差不多完成了，但有一个问题。选择 `|` 现在恰好位于 `[01]\d` 和 `2[0-3]:[0-5]\d` 之间。

也就是说：它只匹配符号左侧或右侧任一表达式。

```none
[01]\d  |  2[0-3]:[0-5]\d
```

此模式查找 `[01]\d` 或 `2[0-3]:[0-5]\d`。

但这是错误的，应该只在正则表达式的“小时”部分使用选择，以允许 `[01]\d` 或 `2[0-3]`。让我们通过将“小时”括在括号中来纠正这个问题：`([01]\d|2[0-3]):[0-5]\d`

最终的解决方案：

```javascript
let regexp = /([01]\d|2[0-3]):[0-5]\d/g;

alert("00:00 10:10 23:59 25:99 1:2".match(regexp)); // 00:00,10:10,23:59
```



# 前瞻断言与后瞻断言



语法为：`x(?=y)`，它表示“仅在后面是 `Y` 时匹配 `X`”。这里的 `X` 和 `Y` 可以是任何模式。

那么对于一个后面跟着 `€` 的整数，正则表达式应该为：`\d+(?=€)`。

```javascript
let str = "1 turkey costs 30€";

alert( str.match(/\d+(?=€)/) ); // 30，数字 1 被忽略了，因为它后面没有 €
```

当我们查找 `X(?=Y)` 时，正则表达式引擎会找到 `X`，然后检查其后是否有 `Y`。如果没有，则跳过潜在匹配，并继续搜索。

例如 `X(?=Y)(?=Z)` 表示：

1. 寻找 `X`。
2. 检查 `Y` 是否紧跟在 `X` 之后（如果不是则跳过）。
3. 检查 `Z` 是否也在 `X` 之后（如果不是则跳过）。
4. 必须是 `X` 后跟 `Y` 和 `Z`，才匹配`X` 。



这只有在模式 `Y` 和 `Z` 不是互斥的情况下才可行。

例如，`\d+(?=\s)(?=.*30)` 查找后跟着空格 `(?=\s)` 的 `\d+`， `(?=.*30)`表示任意字符末尾跟着30：

```javascript
let str = "1 turkey costs 30€";

alert( str.match(/\d+(?=\s)(?=.*30)/) ); // 1
```

在我们给出的字符串中，与数字 `1` 完全匹配。



## [负向前瞻断言](https://zh.javascript.info/regexp-lookahead-lookbehind#fou-ding-de-qian-zhan-duan-yan)

假设我们想要一个数量，而不是来自同一字符串的价格。那是一个数字 `\d+`，后面不是 `€`。

为此，我们可以使用否定的前瞻断言。

语法是：`X(?!Y)`，意思是“搜索 `X`，但前提是后面没有 `Y`”。

```javascript
let str = "2 turkeys cost 60€";

alert( str.match(/\d+\b(?!€)/g) ); // 2（价格不匹配）
```

`/\d+\b(?!€)/g`其中的`(?!€)`表示词边界的后面跟的不是€，对吗?

是的，你的理解是正确的。正则表达式 `/\d+\b(?!€)/g` 中的 `(?!€)` 表示一个负向前瞻断言（negative lookahead assertion），它确保匹配的数字后面不是欧元符号（€）。

## [后瞻断言](https://zh.javascript.info/regexp-lookahead-lookbehind#hou-zhan-duan-yan)

`请注意：只有 V8 引擎的浏览器支持后瞻断言`

后瞻断言也类似，只不过它是在相反的方向上进行条件判断。也就是说，它只允许匹配前面有特定字符串的模式。

语法为如下：

- 肯定的后瞻断言：`(?<=Y)X`，匹配 `X`，仅在前面是 `Y` 的情况下。
- 否定的后瞻断言：`(?<!Y)X`，匹配 `X`，仅在前面不是 `Y` 的情况下。

查找 `$30` 我们将使用 `(?<=\$)\d+` —— 一个前面带 `$` 的数值：

```javascript
let str = "1 turkey costs $30";

// 美元符号被转义 \$
alert( str.match(/(?<=\$)\d+/) ); // 30（跳过了仅仅是数字的值）
```

如果我们需要找到量词 —— 一个前面不带 `$` 的数字，我们可以使用否定的后瞻断言：`(?<!\$)\d+`

```javascript
let str = "2 turkeys cost $60";

alert( str.match(/(?<!\$)\b\d+/g) ); // 2（价格不匹配）
```

## 捕获组

一般来说，前瞻断言和后瞻断言括号中的内容不会成为结果的一部分。

例如，在模式 `\d+(?!€)` 中，`€` 符号就不会出现在匹配结果中。这是很自然的事：我们寻找一个数字 `\d+`，而 `(?=€)` 只是一个测试，表示要匹配的数字后面应该紧跟着 `€` 字符。

但在某些情况下，我们可能还想捕获前瞻断言和后瞻断言所匹配的内容，或者部分内容。这也是可行的。只需要将该部分包装在`额外的括号`中。

在下面的示例中，货币符号 `(€|kr)` 和金额一起被捕获了：

```javascript
let str = "1 turkey costs 30€";
let regexp = /\d+(?=(€|kr))/; // €|kr 两侧有额外的括号

alert( str.match(regexp) ); // 30, €
```

后瞻断言也一样：

```javascript
let str = "1 turkey costs $30";
let regexp = /(?<=(\$|£))\d+/;

alert( str.match(regexp) ); // 30, $
```



# 灾难性回溯



## [简化的例子](https://zh.javascript.info/regexp-catastrophic-backtracking#jian-hua-de-li-zi)

问题出在哪？为什么正则表达式会导致“挂起”？

为了理解它，我们来简化一下例子：移除空格符 `\s?`，使其简化为 `^(\w+)*$`。

同时为了让问题更明显，再用 `\d` 替换掉 `\w`。生成的新正则表达式执行时仍会导致挂起，例如：

```javascript
let regexp = /^(\d+)*$/;

let str = "012345678901234567890123456789z";

// 会消耗很长时间（请小心！）
alert( regexp.test(str) );
```

正则表达式 `^(\d+)$` 在匹配字符串 `"123456789z"` 时，由于 `(\d+)` 中的 `\d+` 是贪婪的，它会尝试匹配尽可能多的字符。每次匹配失败时，正则表达式引擎会回溯并尝试其他可能的组合。这会导致很多不同的组合数。



### 再简化示例:

```javascript
let regexp = /^(\d+)*$/;

let str = "123456789z";

alert( regexp.test(str) );
```

让我们逐步分析每种情况：

1. 第一个数字 `\d+` 有 7 位数，后面跟着一个 2 位数的数字：

- 组合数：2 种

- `(1234567)(89)`

- `(1234567)(8)(9)`

1. 第一个数字 `\d+` 有 6 位数，后面跟着一个 3 位数：

- 组合数：4 种

- `(123456)(789)`

- `(123456)(78)(9)`

- `(123456)(7)(89)`

- `(123456)(7)(8)(9)`

1. 第一个数字 `\d+` 有 5 位数，后面跟着一个 4 位数：

- 组合数：8 种

- `(12345)(6789)`

- `(12345)(678)(9)`

- `(12345)(67)(89)`

- `(12345)(67)(8)(9)`

- `(12345)(6)(789)`

- `(12345)(6)(78)(9)`

- `(12345)(6)(7)(89)`

- `(12345)(6)(7)(8)(9)`

1. 第一个数字 `\d+` 有 4 位数，后面跟着一个 5 位数：

- 组合数：16 种

- `(1234)(56789)`

- `(1234)(5678)(9)`

- `(1234)(567)(89)`

- `(1234)(567)(8)(9)`

- `(1234)(56)(789)`

- `(1234)(56)(78)(9)`

- `(1234)(56)(7)(89)`

- `(1234)(56)(7)(8)(9)`

- `(1234)(5)(6789)`

- `(1234)(5)(678)(9)`

- `(1234)(5)(67)(89)`

- `(1234)(5)(67)(8)(9)`

- `(1234)(5)(6)(789)`

- `(1234)(5)(6)(78)(9)`

- `(1234)(5)(6)(7)(89)`

- `(1234)(5)(6)(7)(8)(9)`

1. 第一个数字 `\d+` 有 3 位数，后面跟着一个 6 位数：

- 组合数：32 种

- 组合情况类似前面，但更多，因为每个数字都可以单独匹配。

1. 第一个数字 `\d+` 有 2 位数，后面跟着一个 7 位数：

- 组合数：64 种

- 组合情况类似前面，但更多，因为每个数字都可以单独匹配。

1. 第一个数字 `\d+` 有 1 位数，后面跟着一个 8 位数：

- 组合数：128 种

- 组合情况类似前面，但更多，因为每个数字都可以单独匹配。

\### 组合数的计算

每次减少一个数字，剩下的数字可以有2的幂次组合数。具体来说，如果第一个数字有 `n` 位数，后面剩下 `m` 位数，那么组合数是 `2^(m-1)`。

由此可见，`let str = "012345678901234567890123456789z";`使用`let regexp = /^(\d+)*$/;`来匹配会造成非常多次的回溯。即第一个数字 `\d+` 有 1 位数，后面跟着一个 19位数时`2^(30-1)=536,870,912`，带来一个5亿多次的极大计算量。

使用错位相减求和法可得总共需要的计算量是:`2^(30)-1=1,073,741,823`次。

现代正则表达式引擎支持占有型量词（Possessive Quantifiers）。如果我们在常规量词之后添加 `+`，则常规量词就变成了占有型量词。也就是说，我们可以使用 `\d++` 替代 `\d+` 来阻止 `+` 回溯。



### [用前瞻视角解决问题](https://zh.javascript.info/regexp-catastrophic-backtracking#yong-qian-zhan-shi-jiao-jie-jue-wen-ti)

我们希望量词，例如 `+` 不要回溯，因为有时回溯没有意义。

在不回溯的情况下尽可能多地重复 `\w` 的模式可以写为：`(?=(\w+))\1`。

让我们解读一下：

- 前瞻断言 `?=` 从当前位置开始，向前查找最长的单词 `\w+`。
- 引擎不会去记住带有 `?=...` 的括号中的内容。所以将 `\w+` 放入括号中，这样引擎就会记住这些内容了。
- ……然后用 `\1` 来引用括号中的内容。





> `"JavaScript".match(/(?=(\w+))\1Script/);` 是不是等同于`"JavaScript".match(/JavaScriptScript/);`?

从技术上讲，这两个正则表达式并不等同。让我们逐一分析它们：

1. `alert("JavaScript".match(/(?=(\w+))\1Script/));`

- `(?=(\w+))` 是一个正向前瞻断言，它匹配一个或多个字母数字字符（`\w+`），但不消耗这些字符。

- `\1` 是一个反向引用，它引用了前瞻断言中捕获的组，即一个或多个字母数字字符。

- `Script` 是字面匹配。

  所以这个正则表达式的意思是：匹配一个或多个字母数字字符，接着是 "Script"，其中前面的字母数字字符组必须与 `\1` 所引用的内容相同。

1. `alert("JavaScript".match(/JavaScriptScript/));`

- 这个正则表达式只是简单地匹配 "JavaScriptScript" 这个字符串。

显然，`"JavaScript"` 字符串中并不包含 "JavaScriptScript"，所以第二个正则表达式会返回 `null`。

让我们实际执行一下第一个正则表达式：

```javascript
alert("JavaScript".match(/(?=(\w+))\1Script/));
```

- 这个正则表达式会尝试在 "JavaScript" 中找到一个或多个字母数字字符，接着是 "Script"。但是在 "JavaScript" 中，没有任何部分符合这种模式（即没有任何部分是一个或多个字母数字字符，后面紧跟 "Script" 并且前面的部分与 `\1` 相同）。

因此，`alert("JavaScript".match(/(?=(\w+))\1Script/));` 也会返回 `null`。

总结：这两个正则表达式并不等同，并且在 "JavaScript" 字符串中，两个正则表达式都会返回 `null`。

> 其中的1是什么?

在正则表达式中，`\1` 是一个反向引用。反向引用用于引用在同一正则表达式中之前捕获的组。具体来说，`\1` 引用的是第一个捕获组，`\2` 引用的是第二个捕获组，以此类推。

让我们更详细地分析一下这个正则表达式：

```javascript
/(?=(\w+))\1Script/
```

- `(?=(\w+))` 是一个正向前瞻断言。正向前瞻断言会在不消耗字符的情况下检查是否存在匹配的模式。这里的模式是 `(\w+)`，即一个或多个字母数字字符，并且它被捕获到第一个捕获组中。

- `\1` 是一个反向引用，它引用了第一个捕获组 `(\w+)` 中的内容。

- `Script` 是字面匹配。

所以，整个正则表达式的意思是：在不消耗字符的情况下，检查是否存在一个或多个字母数字字符，然后匹配这些字符（通过反向引用 `\1`），接着是 "Script"。

举个例子，假设我们有一个字符串 `"JavaScriptScript"`，那么这个正则表达式会按以下步骤进行匹配：

1. `(?=(\w+))` 会匹配 `"JavaScript"`，并捕获到第一个捕获组。

1. `\1` 会引用第一个捕获组中的内容，即 `"JavaScript"`。

1. `Script` 会继续匹配。

所以，整个正则表达式会匹配 `"JavaScriptScript"`。

但是在 `"JavaScript"` 这个字符串中，没有任何部分符合这种模式（即没有任何部分是一个或多个字母数字字符，后面紧跟 "Script" 并且前面的部分与 `\1` 相同），因此这个正则表达式在 `"JavaScript"` 字符串中会返回 `null`。



现在让我们用前瞻断言重写第一个例子中的正则表达式来防止回溯吧：

```javascript
//先返回第一个括号`()`包裹?=(?<word>\w+)`的内容,括号嵌套是从外到内，平级的括号从左到右。
//因此这里的2表示(\w+),2得到的是前瞻断言搜索到的字符,本来这些字符是测试用的,现在直接通过捕获组获取。
let regexp = /^((?=(\w+))\2\s?)*$/;

alert( regexp.test("A good string") ); // true

let str = "An input string that takes a long time or even makes this regex hang!";

alert( regexp.test(str) ); // false，有效且执行的很快！
```

这里我们用 `\2` 而不是 `\1`，因为这里有额外的外部括号。为了防止数字弄混了，我们可以给括号命名，例如 `(?<word>\w+)`。

```javascript
// 括号被命名为 ?<word>，使用 \k<word> 进行引用
let regexp = /^((?=(?<word>\w+))\k<word>\s?)*$/;

let str = "An input string that takes a long time or even makes this regex hang!";

alert( regexp.test(str) ); // false

alert( regexp.test("A correct string") ); // true
```

本文所描述的问题称作“灾难性回溯（Catastrophic Backtracking）”，又译作“回溯陷阱”。

我们介绍了两种解决方式：

- 重写正则表达式，以尽可能降低可能的组合数量。
- 防止回溯。



#### regexp.exec(str)

`regexp.exec(str)` 是 JavaScript 中正则表达式对象的一个方法，它用于在字符串 `str` 中执行一个搜索匹配。这个方法返回一个数组（包含匹配的结果）或者在没有匹配时返回 `null`。与 `String.prototype.match` 方法相比，`Regexp.prototype.exec` 方法提供了更详细的匹配信息。

让我们详细解释一下 `regexp.exec(str)` 的工作原理：

\### 返回值

`regexp.exec(str)` 返回一个数组，其中包含以下内容：

1. 完整匹配：数组的第一个元素是整个匹配的字符串。

1. 捕获组：数组的后续元素是正则表达式中的捕获组的匹配结果。

1. 附加属性：

- `index`：匹配结果在原字符串中的起始位置。

- `input`：被搜索的原字符串。

\### 示例

```javascript
const regexp = /(\w+)\s(\w+)/;
const str = "Hello World";
const result = regexp.exec(str);

console.log(result);
```

输出结果如下：

```javascript
[
  "Hello World", // 完整匹配
  "Hello",       // 第一个捕获组 (\w+)
  "World",       // 第二个捕获组 (\w+)
  index: 0,      // 匹配结果在原字符串中的起始位置
  input: "Hello World" // 被搜索的原字符串
]
```

循环匹配

`regexp.exec` 方法的一个特别之处在于它可以在全局搜索（带有 `g` 标志的正则表达式）中反复调用，以找到所有的匹配：

```javascript
const regexp = /\w+/g;
const str = "Hello World";
let match;

while (  (match = regexp.exec(str) ) !== null) {
  console.log(`Found ${match[0]} at ${match.index}`);
}
```

输出结果如下：

```javascript
Found Hello at 0
Found World at 6
```



> `while`循环存在问题吧，` regexp.exec(str)`不为`null`就会一直循环下去，没有退出条件吧?

其实，这段代码是正确的，并且在全局正则表达式（带有 `g` 标志的正则表达式）中是一个常见的用法。`regexp.exec(str)` 方法在全局模式下会记住上次匹配的位置，并从该位置继续搜索下一个匹配，直到没有更多匹配为止。

具体来说，每次调用 `regexp.exec(str)` 时，正则表达式引擎会从上次匹配结束的位置继续搜索。如果找到了匹配，它会返回一个数组；如果没有找到匹配，它会返回 `null`，从而退出循环。

让我们再详细解释一下这个过程：

\## 解释

1. 第一次调用 `regexp.exec(str)`：

- 从字符串的起始位置开始搜索，找到第一个匹配 `"Hello"`。

- 返回的匹配数组 `match` 包含 `"Hello"`，并且 `match.index` 是 0。

- 输出 `Found Hello at 0`。

1. 第二次调用 `regexp.exec(str)`：

- 从上次匹配结束的位置继续搜索，找到第二个匹配 `"World"`。

- 返回的匹配数组 `match` 包含 `"World"`，并且 `match.index` 是 6。

- 输出 `Found World at 6`。

1. 第三次调用 `regexp.exec(str)`：

- 从上次匹配结束的位置继续搜索，没有找到更多匹配。

- 返回 `null`，循环退出。

- `regexp.exec(str)` 方法在全局模式下会记住上次匹配的位置，因此能够在循环中逐次找到所有匹配。

- 如果正则表达式没有全局标志（即没有 `g` 标志），每次调用 `exec` 方法都会从字符串的起始位置开始搜索，这样就会导致无限循环。

\### 示例：没有全局标志的情况

```javascript
const regexp = /\w+/; // 没有全局标志
const str = "Hello World";
let match;

while ((match = regexp.exec(str)) !== null) {
  console.log(`Found ${match[0]} at ${match.index}`);
}
```

在这种情况下，`regexp.exec(str)` 每次都会从字符串的开头重新开始搜索，导致找到相同的匹配，陷入无限循环。因此，在使用循环时，确保正则表达式具有全局标志是非常重要的。

> 不管是字面量法还是构造函数法，都可以调用exec方法，对吗?

是的，无论是使用字面量法还是构造函数法定义的正则表达式，都可以调用 `exec` 方法来执行匹配操作。两种方法定义的正则表达式在使用上是等价的。

\### 示例对比

\#### 字面量法

使用字面量法定义正则表达式并调用 `exec` 方法：

```javascript
const regexpLiteral = /(\w+)\s(\w+)/;
const str = "Hello World";
const result = regexpLiteral.exec(str);

console.log(result);
// 输出: ["Hello World", "Hello", "World", index: 0, input: "Hello World"]
```

构造函数法

使用构造函数法定义正则表达式并调用 `exec` 方法：

```javascript
const pattern = "(\\w+)\\s(\\w+)";
const regexpConstructor = new RegExp(pattern);
const str = "Hello World";
const result = regexpConstructor.exec(str);

console.log(result);
// 输出: ["Hello World", "Hello", "World", index: 0, input: "Hello World"]
```

- `exec` 方法：`exec` 方法在一个指定的字符串中执行搜索匹配。它返回一个数组（包含匹配的内容）或 `null`（如果没有匹配）。

- 返回的数组包含匹配的子字符串以及所有捕获组。

- 数组的 `index` 属性表示匹配的起始位置。

- 数组的 `input` 属性包含被搜索的字符串。

\### 示例：使用 `exec` 方法

\#### 字面量法

```javascript
const regexpLiteral = /(\d+)-(\d+)-(\d+)/;
const str = "2024-06-23";
const result = regexpLiteral.exec(str);

console.log(result);
// 输出: ["2024-06-23", "2024", "06", "23", index: 0, input: "2024-06-23"]
```

\#### 构造函数法

```javascript
const pattern = "(\\d+)-(\\d+)-(\\d+)";
const regexpConstructor = new RegExp(pattern);
const str = "2024-06-23";
const result = regexpConstructor.exec(str);

console.log(result);
// 输出: ["2024-06-23", "2024", "06", "23", index: 0, input: "2024-06-23"]
```



### lastIndex

`lastIndex` 是正则表达式对象（`RegExp`）的一个属性，用于指定下一次搜索的起始位置。这个属性主要在带有全局标志（`g`）或粘性标志（`y`）的正则表达式中起作用。

\### 详细解释

1. 全局标志（`g`）：

- 当正则表达式带有全局标志时，`lastIndex` 属性会在每次调用匹配方法（如 `exec` 或 `test`）后自动更新，以便下一次搜索从上一次匹配结束的位置开始。

- 这对于在字符串中查找所有匹配项非常有用。

1. 粘性标志（`y`）：

- 当正则表达式带有粘性标志时，`lastIndex` 属性也会在每次调用匹配方法后更新，但下一次匹配必须从 `lastIndex` 位置开始。

\### 示例

以下是一个带有全局标志的正则表达式示例：

```javascript
let str = 'let varName';
let regexp = /\w+/g;

console.log(regexp.lastIndex); // 输出: 0

let match = regexp.exec(str);
console.log(match[0]); // 输出: "let"
console.log(regexp.lastIndex); // 输出: 3 搜索结束的位置，t后面

match = regexp.exec(str);
console.log(match[0]); // 输出: "varName"
console.log(regexp.lastIndex); // 输出: 11 搜索结束的位置，e后面

match = regexp.exec(str);
console.log(match); // 输出: null
console.log(regexp.lastIndex); // 输出: 0
```

1. 初始时，`regexp.lastIndex` 为 `0`，表示从字符串的开始位置进行搜索。

1. 第一次调用 `regexp.exec(str)` 后，匹配到 "let"，`regexp.lastIndex` 更新为 `3`（匹配结束的位置）。

1. 第二次调用 `regexp.exec(str)` 后，匹配到 "varName"，`regexp.lastIndex` 更新为 `11`。

1. 第三次调用 `regexp.exec(str)` 后，没有匹配到任何内容，返回 `null`，`regexp.lastIndex` 重新设置为 `0`。

\### 注意事项

- 仅当正则表达式带有全局标志（`g`）或粘性标志（`y`）时，`lastIndex` 属性才会生效。

- 每次匹配操作后，`lastIndex` 属性会自动更新，以便下一次搜索从正确的位置开始。

- 如果没有匹配到任何内容，`lastIndex` 会重置为 `0`。



我们可以手动将 `lastIndex` 设置为 `4`，从给定的位置开始搜索！

像这样：

```javascript
let str = 'let varName = "value"';

let regexp = /\w+/g; // 没有修饰符 "g"，lastIndex 属性会被忽略

regexp.lastIndex = 4;

let word = regexp.exec(str);
alert(word); // varName
```

请注意：`regexp.exec` 调用从位置 `lastIndex` 开始搜索，然后继续搜索。如果 `lastIndex` 位置没有单词(比如索引`3`)，但单词在索引`3`之后的某个位置，那么单词也会被找到：

```javascript
let str = 'let varName = "value"';

let regexp = /\w+/g;

// 从位置 3 开始搜索
regexp.lastIndex = 3;

let word = regexp.exec(str);
// 在位置 4 找到匹配项
alert(word[0]); // varName
alert(word.index); // 4
```



### 粘性标志 `y` 

- 粘性标志 `y` 强制正则表达式从 `lastIndex` 位置开始匹配。

- 匹配失败时，`lastIndex` 不会重置为 0。

- 适用于需要精确控制匹配位置的场景。

当你手动将 `regexp.lastIndex` 设置为 `4` 时，正则表达式的匹配将从字符串的第 4 个字符（索引 4）开始。如果从这个位置开始没有任何匹配项，则匹配操作将返回 `null`。让我们详细分析一下这个过程。

```javascript
let str = 'let varName';
let regexp = /\w+/y;

regexp.lastIndex = 3;
alert( regexp.exec(str) ); // null（位置 3 有一个空格，不是单词）

regexp.lastIndex = 4;
alert( regexp.exec(str) ); // varName（在位置 4 的单词）
```

字符串 `'let varName'` 中的字符索引如下：

```javascript
Index: 0 1 2 3 4 5 6 7 8 9 10
Chars: l e t   v a r N a m e
```

具体来说：

- 索引 `0` 对应字符 `'l'`

- 索引 `1` 对应字符 `'e'`

- 索引 `2` 对应字符 `'t'`

- 索引 `3` 对应字符 `' '`（空格）

- 索引 `4` 对应字符 `'v'`

- 索引 `5` 对应字符 `'a'`

- 索引 `6` 对应字符 `'r'`

- 索引 `7` 对应字符 `'N'`

- 索引 `8` 对应字符 `'a'`

- 索引 `9` 对应字符 `'m'`

- 索引 `10` 对应字符 `'e'`

想象一下，我们有一个很长的文本，其中根本没有匹配项。然后使用修饰符 `g` 进行搜索，会一直搜索到文本的末尾，并且什么也找不到，这将比使用修饰符 `y` 的搜索花费更多的时间，后者只检查确切的位置。

在像词法分析这样的任务中，通常会在一个确切的位置进行多次搜索，以检查我们在那里有什么。使用修饰符 `y` 是正确实现和良好性能的关键。

# 正则表达式和字符串的方法

在本文中，我们将深入介绍与正则表达式配合使用的各种方法。

## [str.match(regexp)](https://zh.javascript.info/regexp-methods#strmatchregexp)

`str.match(regexp)` 方法在字符串 `str` 中查找 `regexp` 的匹配项。

它有 3 种模式：

1. 如果 `regexp` 不带有修饰符 `g`，则它以数组的形式返回第一个匹配项，其中包含捕获组和属性 `index`（匹配项的位置）、`input`（输入字符串，等于 `str`）：

   ```javascript
   let str = "I love JavaScript";
   
   let result = str.match(/Java(Script)/);
   
   alert( result[0] );     // JavaScript（完全匹配）
   alert( result[1] );     // Script（第一个分组）
   alert( result.length ); // 2
   
   // 其他信息：
   alert( result.index );  // 7（匹配位置）
   alert( result.input );  // I love JavaScript（源字符串）
   ```

2. 如果 `regexp` 带有修饰符 `g`，则它将返回一个包含所有匹配项的数组，但`不包含捕获组`和其它详细信息。

   ```javascript
   let str = "I love JavaScript";
   //不包含捕获组,即使使用了捕获组语法中的括号，也不会包含在返回的数组中
   let result = str.match(/Java(Script)/g);//括号中的(Script)并没有加入数组中
   
   alert( result[0] ); // JavaScript
   alert( result.length ); // 1
   ```

3. 如果没有匹配项，则无论是否带有修饰符 `g`，都将返回 `null`。

   这是一个重要的细微差别。如果没有匹配项，我们得到的不是一个空数组，而是 `null`。忘记这一点很容易出错，例如：

   ```javascript
   let str = "I love JavaScript";
   
   let result = str.match(/HTML/);
   
   alert(result); // null
   alert(result.length); // Error: Cannot read property 'length' of null
   ```

   如果我们希望结果是一个数组，我们可以这样写：

   ```javascript
   let result = str.match(regexp) || [];
   ```

## [str.matchAll(regexp)](https://zh.javascript.info/regexp-methods#strmatchallregexp)

**最近新增的特性**

这是一个最近添加到 JavaScript 的特性。 旧式浏览器可能需要 polyfills.

方法 `str.matchAll(regexp)` 是 `str.match` 的“更新、改进”的变体。

它主要用来搜索所有组的所有匹配项。

与 `match` 相比有 3 个区别：

1. 它返回一个包含匹配项的可迭代对象，而不是数组。我们可以用 `Array.from` 将其转换为一个常规数组。
2. 每个匹配项均以一个包含捕获组的数组形式返回（返回格式与不带修饰符 `g` 的 `str.match` 相同）。
3. 如果没有结果，则返回的是一个空的可迭代对象而不是 `null`。

用法示例：

```javascript
let str = '<h1>Hello, world!</h1>';
let regexp = /<(.*?)>/g;

let matchAll = str.matchAll(regexp);

alert(matchAll); // [object RegExp String Iterator]，不是数组，而是一个可迭代对象

matchAll = Array.from(matchAll); // 现在是数组了

let firstMatch = matchAll[0];
alert( firstMatch[0] );  // <h1>
alert( firstMatch[1] );  // h1
alert( firstMatch.index );  // 0
alert( firstMatch.input );  // <h1>Hello, world!</h1>
```

如果我们用 `for..of` 来遍历 `matchAll` 的匹配项，那么我们就不需要 `Array.from` 了。

## [str.split(regexp|substr, limit)](https://zh.javascript.info/regexp-methods#strsplitregexpsubstrlimit)

使用正则表达式（或子字符串）作为分隔符来分割字符串。

我们可以用 `split` 来分割字符串，像这样：

```javascript
alert('12-34-56'.split('-')) // 数组 ['12', '34', '56']
```

但同样，我们也可以用正则表达式：

```javascript
alert('12, 34, 56'.split(/,\s*/)) // 数组 ['12', '34', '56']
```

## [str.search(regexp)](https://zh.javascript.info/regexp-methods#strsearchregexp)

方法 `str.search(regexp)` 返回第一个匹配项的位置，如果没找到，则返回 `-1`：

```javascript
let str = "A drop of ink may make a million think";

alert( str.search( /ink/i ) ); // 10（第一个匹配位置）
```

**重要限制：`search` 仅查找第一个匹配项。**

如果我们需要其他匹配项的位置，则应使用其他方法，例如用 `str.matchAll(regexp)` 查找所有位置。

## [str.replace(str|regexp, str|func)](https://zh.javascript.info/regexp-methods#strreplacestrregexpstrfunc)

这是用于搜索和替换的通用方法，是最有用的方法之一。它是搜索和替换字符串的瑞士军刀。

我们可以在不使用正则表达式的情况下使用它来搜索和替换子字符串：

```javascript
// 用冒号替换连字符
alert('12-34-56'.replace("-", ":")) // 12:34-56
```

不过有一个陷阱。

**当 `replace` 的第一个参数是字符串时，它只替换第一个匹配项。**

你可以在上面的示例中看到：只有第一个 `"-"` 被替换为了 `":"`。

如要找到所有的连字符，我们不应该用字符串 `"-"`，而应使用带 `g` 修饰符的正则表达式 `/-/g`：

```javascript
// 将所有连字符都替换为冒号
alert( '12-34-56'.replace( /-/g, ":" ) )  // 12:34:56
```

第二个参数是替换字符串。我们可以在其中使用特殊字符：

| 符号      | 替换字符串中的行为                                           |
| :-------- | :----------------------------------------------------------- |
| `$&`      | 插入整个匹配项                                               |
| $`        | 插入字符串中匹配项之前的字符串部分                           |
| `$'`      | 插入字符串中匹配项之后的字符串部分                           |
| `$n`      | 如果 `n` 是一个 1-2 位的数字，则插入第 n 个分组的内容，详见 [捕获组](https://zh.javascript.info/regexp-groups) |
| `$<name>` | 插入带有给定 `name` 的括号内的内容，详见 [捕获组](https://zh.javascript.info/regexp-groups) |
| `$$`      | 插入字符 `$`                                                 |

例如：

```javascript
let str = "John Smith";

// 交换名字和姓氏
alert(str.replace(/(john) (smith)/i, '$2, $1')) // Smith, John
```

**对于需要“智能”替换的场景，第二个参数可以是一个函数。**

每次匹配都会调用这个函数，并且返回的值将作为替换字符串插入。

该函数 `func(match, p1, p2, ..., pn, offset, input, groups)` 带参数调用：

1. `match` —— 匹配项，
2. `p1, p2, ..., pn` —— 捕获组的内容（如有），
3. `offset` —— 匹配项的位置，
4. `input` —— 源字符串，
5. `groups` —— 具有命名的捕获组的对象。

如果正则表达式中没有括号，则只有 3 个参数：`func(str, offset, input)`。

例如，将所有匹配项都大写：

```javascript
let str = "html and css";

let result = str.replace(/html|css/gi, str => str.toUpperCase());

alert(result); // HTML and CSS
```

将每个匹配项替换为其在字符串中的位置：

```javascript
alert("Ho-Ho-ho".replace(/ho/gi, (match, offset) => offset)); // 0-3-6
```

在下面的示例中，有两对括号，因此将使用 5 个参数调用替换函数：第一个是完全匹配项，然后是 2 对括号，然后是（在示例中未使用）匹配位置和源字符串：

```javascript
let str = "John Smith";

let result = str.replace(/(\w+) (\w+)/, (match, name, surname) => `${surname}, ${name}`);

alert(result); // Smith, John
```

如果有许多组，用 rest 参数（…）可以很方便的访问：

```javascript
let str = "John Smith";

let result = str.replace(/(\w+) (\w+)/, (...match) => `${match[2]}, ${match[1]}`);

alert(result); // Smith, John
```

或者，如果我们使用的是命名组，则带有它们的 `groups` 对象始终是最后一个对象，所以我们可以像这样获取它：

```javascript
let str = "John Smith";

let result = str.replace(/(?<name>\w+) (?<surname>\w+)/, (...match) => {
  let groups = match.pop();

  return `${groups.surname}, ${groups.name}`;
});

alert(result); // Smith, John
```

使用函数可以为我们提供终极替换功能，因为它可以获取匹配项的所有信息，可以访问外部变量，可以做任何事。

## [str.replaceAll(str|regexp, str|func)](https://zh.javascript.info/regexp-methods#strreplaceallstrregexpstrfunc)

这个方法与 `str.replace` 本质上是一样的，但有两个主要的区别：

1. 如果第一个参数是一个`字符串`，它会替换 **所有出现的** 和第一个参数相同的字符串，而 `replace` 只会替换 **第一个**。
2. 如果第一个参数是一个没有修饰符 `g` 的正则表达式，则会报错。带有修饰符 `g`，它的工作方式与 `replace` 相同。

`replaceAll` 的主要用途是替换所有出现的字符串。

像这样：

```javascript
// 使用冒号替换所有破折号
alert('12-34-56'.replaceAll("-", ":")) // 12:34:56
alert('12-34-56'.replaceAll(/-/g, ":")) // 12:34:56 不带g将会报错
```

## [regexp.exec(str)](https://zh.javascript.info/regexp-methods#regexpexecstr)

`regexp.exec(str)` 方法返回字符串 `str` 中的 `regexp` 匹配项。与以前的方法不同，它是在正则表达式而不是在字符串上调用的。

它的行为取决于正则表达式是否具有修饰符 `g`。

如果没有修饰符 `g`，则 `regexp.exec(str)` 会返回与 第一个匹配项，就像 `str.match(regexp)` 那样。这种行为并没有带来任何新的东西。

但是，如果有修饰符 `g`，那么：

- 调用 `regexp.exec(str)` 会返回第一个匹配项，并将紧随其后的位置保存在属性 `regexp.lastIndex` 中。
- 下一次这样的调用会从位置 `regexp.lastIndex` 开始搜索，返回下一个匹配项，并将其后的位置保存在 `regexp.lastIndex` 中。
- ……以此类推。
- 如果没有匹配项，则 `regexp.exec` 返回 `null`，并将 `regexp.lastIndex` 重置为 `0`。

因此，重复调用会一个接一个地返回所有匹配项，使用属性 `regexp.lastIndex` 来跟踪当前搜索位置。

过去，在将 `str.matchAll` 方法添加到 JavaScript 之前，会在循环中调用 `regexp.exec` 来获取组的所有匹配项：

```javascript
let str = 'More about JavaScript at https://javascript.info';
let regexp = /javascript/ig;

let result;

while (result = regexp.exec(str)) {
  alert( `Found ${result[0]} at position ${result.index}` );
  // 在位置 11 找到了 JavaScript，然后
  // 在位置 33 找到了 javascript
}
```

这现在也有效，尽管对于较新的浏览器 `str.matchAll` 通常更方便。

**我们可以通过手动设置 `lastIndex`，用 `regexp.exec` 从给定位置进行搜索。**

例如：

```javascript
let str = 'Hello, world!';

let regexp = /\w+/g; // 没有修饰符 "g"，lastIndex 属性会被忽略
regexp.lastIndex = 5; // 从第 5 个位置搜索（从逗号开始）

alert( regexp.exec(str) ); // world
```

如果正则表达式带有修饰符 `y`，则搜索将精确地在 `regexp.lastIndex` 位置执行，不会再进一步。

让我们将上面示例中的 `g` 修饰符替换为 `y`。现在没有找到匹配项，因为在位置 `5` 处没有单词：

```javascript
let str = 'Hello, world!';

let regexp = /\w+/y;
regexp.lastIndex = 5; // 在位置 5 精确查找

alert( regexp.exec(str) ); // null
```

当我们需要通过正则表达式在确切位置而不是其后的某处从字符串中“读取”某些内容时，这很方便。

## [regexp.test(str)](https://zh.javascript.info/regexp-methods#regexpteststr)

方法 `regexp.test(str)` 查找匹配项，然后返回 `true/false` 表示是否存在。

例如：

```javascript
let str = "I love JavaScript";

// 这两个测试相同
alert( /love/i.test(str) ); // true
alert( str.search(/love/i) != -1 ); // true
```

一个否定答案的例子：

```javascript
let str = "Bla-bla-bla";

alert( /love/i.test(str) ); // false
alert( str.search(/love/i) != -1 ); // false 没有找到返回-1,找到了返回索引
```

如果正则表达式带有修饰符 `g`，则 `regexp.test` 从 `regexp.lastIndex` 属性开始查找并更新此属性，就像 `regexp.exec` 一样。

因此，我们可以用它从给定位置进行查找：

```javascript
let regexp = /love/gi;

let str = "I love JavaScript";

// 从位置 10 开始搜索：
regexp.lastIndex = 10;
alert( regexp.test(str) ); // false（没有匹配项）
```

**相同的全局正则表达式在不同的源字符串上测试可能会失败**

如果我们在不同的源字符串上应用相同的全局正则表达式，可能会出现错误的结果，因为 `regexp.test` 的调用会增加 `regexp.lastIndex` 属性值，因此在另一个字符串中的搜索可能是从非 0 位置开始的。

例如，这里我们在同一文本上调用 `regexp.test` 两次，而第二次调用失败了：

```javascript
let regexp = /javascript/g;  // （新建立的 regexp：regexp.lastIndex=0)

alert( regexp.test("javascript") ); // true（现在 regexp.lastIndex=10）
alert( regexp.test("javascript") ); // false
```

这正是因为在第二个测试中 `regexp.lastIndex` 不为零。

如要解决这个问题，我们可以在每次搜索之前设置 `regexp.lastIndex = 0`。或者，不要在正则表达式上调用方法，而是使用字符串方法 `str.match/search/...`，这些方法不使用 `lastIndex`。

